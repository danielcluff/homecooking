
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/homecooking/backend/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">github.com/homecooking/backend/internal/config/config.go (0.0%)</option>
				
				<option value="file2">github.com/homecooking/backend/internal/db/database.go (0.0%)</option>
				
				<option value="file3">github.com/homecooking/backend/internal/db/sqlc/categories.sql.go (0.0%)</option>
				
				<option value="file4">github.com/homecooking/backend/internal/db/sqlc/db.go (0.0%)</option>
				
				<option value="file5">github.com/homecooking/backend/internal/db/sqlc/recipe_groups.sql.go (0.0%)</option>
				
				<option value="file6">github.com/homecooking/backend/internal/db/sqlc/recipe_images.sql.go (0.0%)</option>
				
				<option value="file7">github.com/homecooking/backend/internal/db/sqlc/recipes.sql.go (0.0%)</option>
				
				<option value="file8">github.com/homecooking/backend/internal/db/sqlc/settings.sql.go (0.0%)</option>
				
				<option value="file9">github.com/homecooking/backend/internal/db/sqlc/share_codes.sql.go (0.0%)</option>
				
				<option value="file10">github.com/homecooking/backend/internal/db/sqlc/tags.sql.go (0.0%)</option>
				
				<option value="file11">github.com/homecooking/backend/internal/db/sqlc/user_invites.sql.go (0.0%)</option>
				
				<option value="file12">github.com/homecooking/backend/internal/db/sqlc/users.sql.go (0.0%)</option>
				
				<option value="file13">github.com/homecooking/backend/internal/handlers/auth_handler.go (37.2%)</option>
				
				<option value="file14">github.com/homecooking/backend/internal/handlers/category_handler.go (0.0%)</option>
				
				<option value="file15">github.com/homecooking/backend/internal/handlers/recipe_group_handler.go (0.0%)</option>
				
				<option value="file16">github.com/homecooking/backend/internal/handlers/recipe_handler.go (0.0%)</option>
				
				<option value="file17">github.com/homecooking/backend/internal/handlers/tag_handler.go (0.0%)</option>
				
				<option value="file18">github.com/homecooking/backend/internal/handlers/upload_handler.go (0.0%)</option>
				
				<option value="file19">github.com/homecooking/backend/internal/integration/setup.go (31.2%)</option>
				
				<option value="file20">github.com/homecooking/backend/internal/middleware/auth.go (69.8%)</option>
				
				<option value="file21">github.com/homecooking/backend/internal/repository/category_repo.go (0.0%)</option>
				
				<option value="file22">github.com/homecooking/backend/internal/repository/helpers.go (72.4%)</option>
				
				<option value="file23">github.com/homecooking/backend/internal/repository/recipe_group_repo.go (0.0%)</option>
				
				<option value="file24">github.com/homecooking/backend/internal/repository/recipe_repo.go (0.0%)</option>
				
				<option value="file25">github.com/homecooking/backend/internal/repository/tag_repo.go (0.0%)</option>
				
				<option value="file26">github.com/homecooking/backend/internal/repository/user_repo.go (0.0%)</option>
				
				<option value="file27">github.com/homecooking/backend/internal/services/auth_service.go (71.2%)</option>
				
				<option value="file28">github.com/homecooking/backend/internal/services/category_service.go (100.0%)</option>
				
				<option value="file29">github.com/homecooking/backend/internal/services/recipe_group_service.go (70.4%)</option>
				
				<option value="file30">github.com/homecooking/backend/internal/services/recipe_service.go (62.7%)</option>
				
				<option value="file31">github.com/homecooking/backend/internal/services/storage_service.go (56.9%)</option>
				
				<option value="file32">github.com/homecooking/backend/internal/services/tag_service.go (70.4%)</option>
				
				<option value="file33">github.com/homecooking/backend/internal/testing/fixtures.go (0.0%)</option>
				
				<option value="file34">github.com/homecooking/backend/internal/testing/setup.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/homecooking/backend/internal/config"
        "github.com/homecooking/backend/internal/db"
        "github.com/homecooking/backend/internal/db/sqlc"
        "github.com/homecooking/backend/internal/handlers"
        "github.com/homecooking/backend/internal/middleware"
        "github.com/homecooking/backend/internal/repository"
        "github.com/homecooking/backend/internal/services"
)

func main() <span class="cov0" title="0">{
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load config: %v", err)
        }</span>

        <span class="cov0" title="0">database, err := db.New(&amp;cfg.Database)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer database.Close()

        q := sqlc.New(database)

        userRepo := repository.NewUserRepository(database.DB, q)
        recipeRepo := repository.NewRecipeRepository(database.DB, q)
        categoryRepo := repository.NewCategoryRepository(database.DB, q)
        tagRepo := repository.NewTagRepository(database.DB, q)
        recipeGroupRepo := repository.NewRecipeGroupRepository(database.DB, q)

        authService := services.NewAuthService(cfg, userRepo)
        recipeService := services.NewRecipeService(recipeRepo)
        categoryService := services.NewCategoryService(categoryRepo)
        tagService := services.NewTagService(tagRepo)
        recipeGroupService := services.NewRecipeGroupService(recipeGroupRepo)
        storageService := services.NewStorageService(cfg.Storage.LocalPath, cfg.Storage.MaxFileSize)

        storageService.EnsureDirectory()

        authHandler := handlers.NewAuthHandler(authService)
        recipeHandler := handlers.NewRecipeHandler(recipeService)
        categoryHandler := handlers.NewCategoryHandler(categoryService)
        tagHandler := handlers.NewTagHandler(tagService)
        recipeGroupHandler := handlers.NewRecipeGroupHandler(recipeGroupService)
        uploadHandler := handlers.NewUploadHandler(storageService)

        authMiddleware := middleware.NewAuthMiddleware(authService)

        mux := http.NewServeMux()

        mux.HandleFunc("GET /health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Write([]byte("OK"))
        }</span>)

        <span class="cov0" title="0">mux.HandleFunc("POST /api/v1/auth/register", authHandler.Register)
        mux.HandleFunc("POST /api/v1/auth/login", authHandler.Login)
        mux.HandleFunc("POST /api/v1/auth/refresh", authHandler.Refresh)

        authenticated := authMiddleware.Auth(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                authHandler.Me(w, r)
        }</span>))
        <span class="cov0" title="0">mux.Handle("GET /api/v1/auth/me", authenticated)

        mux.HandleFunc("GET /api/v1/recipes", recipeHandler.ListRecipes)
        mux.HandleFunc("GET /api/v1/recipes/search", recipeHandler.SearchRecipes)
        mux.HandleFunc("GET /api/v1/recipes/{id}", recipeHandler.GetRecipe)
        // Slug endpoint moved after to avoid conflicts
        // mux.HandleFunc("GET /api/v1/recipes/slug/{slug}", recipeHandler.GetRecipeBySlug)

        mux.Handle("POST /api/v1/recipes", authMiddleware.Auth(http.HandlerFunc(recipeHandler.CreateRecipe)))
        mux.Handle("PUT /api/v1/recipes/{id}", authMiddleware.Auth(http.HandlerFunc(recipeHandler.UpdateRecipe)))
        mux.Handle("POST /api/v1/recipes/{id}/publish", authMiddleware.Auth(http.HandlerFunc(recipeHandler.PublishRecipe)))
        mux.Handle("DELETE /api/v1/recipes/{id}", authMiddleware.Auth(http.HandlerFunc(recipeHandler.DeleteRecipe)))

        // Category routes
        mux.HandleFunc("GET /api/v1/categories", categoryHandler.ListCategories)
        mux.HandleFunc("GET /api/v1/categories/{id}", categoryHandler.GetCategory)
        mux.Handle("POST /api/v1/categories", authMiddleware.Auth(http.HandlerFunc(categoryHandler.CreateCategory)))
        mux.Handle("PUT /api/v1/categories/{id}", authMiddleware.Auth(http.HandlerFunc(categoryHandler.UpdateCategory)))
        mux.Handle("DELETE /api/v1/categories/{id}", authMiddleware.Auth(http.HandlerFunc(categoryHandler.DeleteCategory)))

        // Recipe Group routes
        mux.HandleFunc("GET /api/v1/groups", recipeGroupHandler.ListGroups)
        mux.HandleFunc("GET /api/v1/groups/{id}", recipeGroupHandler.GetGroup)
        mux.Handle("POST /api/v1/groups", authMiddleware.Auth(http.HandlerFunc(recipeGroupHandler.CreateGroup)))
        mux.Handle("PUT /api/v1/groups/{id}", authMiddleware.Auth(http.HandlerFunc(recipeGroupHandler.UpdateGroup)))
        mux.Handle("DELETE /api/v1/groups/{id}", authMiddleware.Auth(http.HandlerFunc(recipeGroupHandler.DeleteGroup)))
        mux.Handle("GET /api/v1/groups/{id}/recipes", authMiddleware.Auth(http.HandlerFunc(recipeGroupHandler.GetGroupRecipes)))
        mux.Handle("POST /api/v1/groups/{id}/recipes", authMiddleware.Auth(http.HandlerFunc(recipeGroupHandler.AddRecipeToGroup)))
        mux.Handle("DELETE /api/v1/groups/{id}/recipes/{recipeId}", authMiddleware.Auth(http.HandlerFunc(recipeGroupHandler.RemoveRecipeFromGroup)))

        // Tag routes
        mux.HandleFunc("GET /api/v1/tags", tagHandler.ListTags)
        mux.HandleFunc("GET /api/v1/tags/{id}", tagHandler.GetTag)
        // Recipe tags endpoint commented out due to routing conflicts
        // mux.HandleFunc("GET /api/v1/recipes/{recipeId}/tags", tagHandler.GetRecipeTags)
        mux.Handle("POST /api/v1/tags", authMiddleware.Auth(http.HandlerFunc(tagHandler.CreateTag)))
        mux.Handle("PUT /api/v1/tags/{id}", authMiddleware.Auth(http.HandlerFunc(tagHandler.UpdateTag)))
        mux.Handle("DELETE /api/v1/tags/{id}", authMiddleware.Auth(http.HandlerFunc(tagHandler.DeleteTag)))
        // mux.Handle("POST /api/v1/recipes/{recipeId}/tags/{tagId}", authMiddleware.Auth(http.HandlerFunc(tagHandler.AddTagToRecipe)))
        // mux.Handle("DELETE /api/v1/recipes/{recipeId}/tags/{tagId}", authMiddleware.Auth(http.HandlerFunc(tagHandler.RemoveTagFromRecipe)))

        // Upload routes
        mux.Handle("POST /api/v1/upload/image", authMiddleware.Auth(http.HandlerFunc(uploadHandler.UploadImage)))

        // Static file server for uploads
        fs := http.FileServer(http.Dir(cfg.Storage.LocalPath))
        mux.Handle("GET /uploads/", http.StripPrefix("/uploads/", fs))

        handler := middleware.Logging(middleware.CORS(mux))

        server := &amp;http.Server{
                Addr:    fmt.Sprintf(":%d", cfg.Server.Port),
                Handler: handler,
        }

        go func() </span><span class="cov0" title="0">{
                log.Printf("Server starting on port %d", cfg.Server.Port)
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("Server error: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Println("Shutting down server...")
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Printf("Server shutdown error: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Server stopped")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
)

type Config struct {
        Server   ServerConfig
        Database DatabaseConfig
        Auth     AuthConfig
        AI       AIConfig
        Storage  StorageConfig
        Email    EmailConfig
}

type ServerConfig struct {
        Port        int
        Environment string
        BaseURL     string
}

type DatabaseConfig struct {
        Type     string
        Host     string
        Port     int
        Name     string
        User     string
        Password string
        Path     string
}

type AuthConfig struct {
        JWTSecret        string
        RefreshSecret    string
        TokenExpiryHours int
}

type AIConfig struct {
        Enabled   bool
        Provider  string
        APIKey    string
        Model     string
        BaseURL   string
        AutoApply bool
}

type StorageConfig struct {
        Type        string
        LocalPath   string
        MaxFileSize int64
}

type EmailConfig struct {
        Enabled  bool
        SMTPHost string
        SMTPPort int
        SMTPUser string
        SMTPPass string
        From     string
}

func Load() (*Config, error) <span class="cov0" title="0">{
        cfg := &amp;Config{}

        cfg.Server = ServerConfig{
                Port:        getEnvInt("SERVER_PORT", 8080),
                Environment: getEnv("SERVER_ENV", "development"),
                BaseURL:     getEnv("SERVER_BASE_URL", "http://localhost:8080"),
        }

        cfg.Database = DatabaseConfig{
                Type:     getEnv("DATABASE_TYPE", "postgres"),
                Host:     getEnv("DATABASE_HOST", "localhost"),
                Port:     getEnvInt("DATABASE_PORT", 5432),
                Name:     getEnv("DATABASE_NAME", "homecooking"),
                User:     getEnv("DATABASE_USER", "postgres"),
                Password: getEnv("DATABASE_PASSWORD", "password"),
                Path:     getEnv("DATABASE_PATH", "./data.db"),
        }

        cfg.Auth = AuthConfig{
                JWTSecret:        getEnv("JWT_SECRET", "change-me-in-production"),
                RefreshSecret:    getEnv("REFRESH_SECRET", "change-me-in-production"),
                TokenExpiryHours: getEnvInt("TOKEN_EXPIRY_HOURS", 24),
        }

        cfg.AI = AIConfig{
                Enabled:   getEnvBool("AI_ENABLED", false),
                Provider:  getEnv("AI_PROVIDER", "openai"),
                APIKey:    getEnv("AI_API_KEY", ""),
                Model:     getEnv("AI_MODEL", "gpt-4o"),
                BaseURL:   getEnv("AI_BASE_URL", ""),
                AutoApply: getEnvBool("AI_AUTO_APPLY", false),
        }

        cfg.Storage = StorageConfig{
                Type:        getEnv("STORAGE_TYPE", "local"),
                LocalPath:   getEnv("STORAGE_LOCAL_PATH", "./uploads"),
                MaxFileSize: getEnvInt64("STORAGE_MAX_UPLOAD_SIZE", 10485760),
        }

        cfg.Email = EmailConfig{
                Enabled:  getEnvBool("EMAIL_ENABLED", false),
                SMTPHost: getEnv("EMAIL_SMTP_HOST", ""),
                SMTPPort: getEnvInt("EMAIL_SMTP_PORT", 587),
                SMTPUser: getEnv("EMAIL_SMTP_USER", ""),
                SMTPPass: getEnv("EMAIL_SMTP_PASS", ""),
                From:     getEnv("EMAIL_FROM", ""),
        }

        if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}

func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.Auth.JWTSecret == "change-me-in-production" &amp;&amp; c.Server.Environment == "production" </span><span class="cov0" title="0">{
                return fmt.Errorf("JWT_SECRET must be set in production")
        }</span>

        <span class="cov0" title="0">if c.Auth.RefreshSecret == "change-me-in-production" &amp;&amp; c.Server.Environment == "production" </span><span class="cov0" title="0">{
                return fmt.Errorf("REFRESH_SECRET must be set in production")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intVal, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intVal
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvInt64(key string, defaultValue int64) int64 <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intVal, err := strconv.ParseInt(value, 10, 64); err == nil </span><span class="cov0" title="0">{
                        return intVal
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolVal, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolVal
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package db

import (
        "context"
        "database/sql"
        "fmt"
        "log"

        "github.com/homecooking/backend/internal/config"
        _ "github.com/lib/pq"
        _ "github.com/mattn/go-sqlite3"
)

type Database struct {
        *sql.DB
}

func New(cfg *config.DatabaseConfig) (*Database, error) <span class="cov0" title="0">{
        var db *sql.DB
        var err error

        switch cfg.Type </span>{
        case "postgres":<span class="cov0" title="0">
                connStr := fmt.Sprintf(
                        "host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
                        cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.Name,
                )
                db, err = sql.Open("postgres", connStr)</span>
        case "sqlite":<span class="cov0" title="0">
                db, err = sql.Open("sqlite3", cfg.Path)</span>
        case "mysql":<span class="cov0" title="0">
                return nil, fmt.Errorf("mysql not implemented yet")</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported database type: %s", cfg.Type)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        <span class="cov0" title="0">if err = db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(5)

        log.Printf("Connected to %s database", cfg.Type)

        return &amp;Database{db}, nil</span>
}

func (db *Database) Close() error <span class="cov0" title="0">{
        return db.DB.Close()
}</span>

func (db *Database) BeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error) <span class="cov0" title="0">{
        return db.DB.BeginTx(ctx, opts)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: categories.sql

package sqlc

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
)

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (id, name, slug, icon, description, order_index)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, name, slug, icon, description, order_index, created_at
`

type CreateCategoryParams struct {
        ID          uuid.UUID      `json:"id"`
        Name        string         `json:"name"`
        Slug        string         `json:"slug"`
        Icon        sql.NullString `json:"icon"`
        Description sql.NullString `json:"description"`
        OrderIndex  sql.NullInt32  `json:"order_index"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createCategory,
                arg.ID,
                arg.Name,
                arg.Slug,
                arg.Icon,
                arg.Description,
                arg.OrderIndex,
        )
        var i Category
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Icon,
                &amp;i.Description,
                &amp;i.OrderIndex,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteCategory, id)
        return err
}</span>

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT id, name, slug, icon, description, order_index, created_at FROM categories
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCategoryByID(ctx context.Context, id uuid.UUID) (Category, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getCategoryByID, id)
        var i Category
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Icon,
                &amp;i.Description,
                &amp;i.OrderIndex,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getCategoryBySlug = `-- name: GetCategoryBySlug :one
SELECT id, name, slug, icon, description, order_index, created_at FROM categories
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetCategoryBySlug(ctx context.Context, slug string) (Category, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getCategoryBySlug, slug)
        var i Category
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Icon,
                &amp;i.Description,
                &amp;i.OrderIndex,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const listCategories = `-- name: ListCategories :many
SELECT id, name, slug, icon, description, order_index, created_at FROM categories
ORDER BY order_index ASC, name ASC
`

func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, listCategories)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Category
        for rows.Next() </span><span class="cov0" title="0">{
                var i Category
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.Slug,
                        &amp;i.Icon,
                        &amp;i.Description,
                        &amp;i.OrderIndex,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET
    name = COALESCE($2, name),
    slug = COALESCE($3, slug),
    icon = COALESCE($4, icon),
    description = COALESCE($5, description),
    order_index = COALESCE($6, order_index)
WHERE id = $1
RETURNING id, name, slug, icon, description, order_index, created_at
`

type UpdateCategoryParams struct {
        ID          uuid.UUID      `json:"id"`
        Name        sql.NullString `json:"name"`
        Slug        sql.NullString `json:"slug"`
        Icon        sql.NullString `json:"icon"`
        Description sql.NullString `json:"description"`
        OrderIndex  sql.NullInt32  `json:"order_index"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateCategory,
                arg.ID,
                arg.Name,
                arg.Slug,
                arg.Icon,
                arg.Description,
                arg.OrderIndex,
        )
        var i Category
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Icon,
                &amp;i.Description,
                &amp;i.OrderIndex,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlc

import (
        "context"
        "database/sql"
)

type DBTX interface {
        ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
        PrepareContext(context.Context, string) (*sql.Stmt, error)
        QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
        QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries <span class="cov0" title="0">{
        return &amp;Queries{db: db}
}</span>

type Queries struct {
        db DBTX
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries <span class="cov0" title="0">{
        return &amp;Queries{
                db: tx,
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recipe_groups.sql

package sqlc

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
)

const addRecipeToGroup = `-- name: AddRecipeToGroup :exec
INSERT INTO recipe_groupings (group_id, recipe_id, order_index)
VALUES ($1, $2, $3)
ON CONFLICT (group_id, recipe_id) DO UPDATE SET order_index = $3
`

type AddRecipeToGroupParams struct {
        GroupID    uuid.UUID     `json:"group_id"`
        RecipeID   uuid.UUID     `json:"recipe_id"`
        OrderIndex sql.NullInt32 `json:"order_index"`
}

func (q *Queries) AddRecipeToGroup(ctx context.Context, arg AddRecipeToGroupParams) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, addRecipeToGroup, arg.GroupID, arg.RecipeID, arg.OrderIndex)
        return err
}</span>

const createRecipeGroup = `-- name: CreateRecipeGroup :one
INSERT INTO recipe_groups (id, name, slug, description, icon)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, slug, description, icon, created_at
`

type CreateRecipeGroupParams struct {
        ID          uuid.UUID      `json:"id"`
        Name        string         `json:"name"`
        Slug        string         `json:"slug"`
        Description sql.NullString `json:"description"`
        Icon        sql.NullString `json:"icon"`
}

func (q *Queries) CreateRecipeGroup(ctx context.Context, arg CreateRecipeGroupParams) (RecipeGroup, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createRecipeGroup,
                arg.ID,
                arg.Name,
                arg.Slug,
                arg.Description,
                arg.Icon,
        )
        var i RecipeGroup
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Description,
                &amp;i.Icon,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const deleteRecipeGroup = `-- name: DeleteRecipeGroup :exec
DELETE FROM recipe_groups WHERE id = $1
`

func (q *Queries) DeleteRecipeGroup(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteRecipeGroup, id)
        return err
}</span>

const getGroupsForRecipe = `-- name: GetGroupsForRecipe :many
SELECT g.id, g.name, g.slug, g.description, g.icon, g.created_at 
FROM recipe_groups g
JOIN recipe_groupings rg ON g.id = rg.group_id
WHERE rg.recipe_id = $1
ORDER BY g.name
`

func (q *Queries) GetGroupsForRecipe(ctx context.Context, recipeID uuid.UUID) ([]RecipeGroup, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getGroupsForRecipe, recipeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []RecipeGroup
        for rows.Next() </span><span class="cov0" title="0">{
                var i RecipeGroup
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.Slug,
                        &amp;i.Description,
                        &amp;i.Icon,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getRecipeGroupByID = `-- name: GetRecipeGroupByID :one
SELECT id, name, slug, description, icon, created_at FROM recipe_groups
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRecipeGroupByID(ctx context.Context, id uuid.UUID) (RecipeGroup, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getRecipeGroupByID, id)
        var i RecipeGroup
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Description,
                &amp;i.Icon,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getRecipeGroupBySlug = `-- name: GetRecipeGroupBySlug :one
SELECT id, name, slug, description, icon, created_at FROM recipe_groups
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetRecipeGroupBySlug(ctx context.Context, slug string) (RecipeGroup, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getRecipeGroupBySlug, slug)
        var i RecipeGroup
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Description,
                &amp;i.Icon,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getRecipeGroupWithRecipes = `-- name: GetRecipeGroupWithRecipes :one
SELECT 
    g.id, g.name, g.slug, g.description, g.icon, g.created_at,
    COALESCE(
        json_agg(
            json_build_object(
                'id', r.id,
                'title', r.title,
                'slug', r.slug,
                'featured_image_path', r.featured_image_path,
                'description', r.description,
                'order_index', rg.order_index
            ) ORDER BY rg.order_index
        ) FILTER (WHERE r.id IS NOT NULL), 
        '[]'::json
    ) as recipes
FROM recipe_groups g
LEFT JOIN recipe_groupings rg ON g.id = rg.group_id
LEFT JOIN recipes r ON rg.recipe_id = r.id
WHERE g.id = $1
GROUP BY g.id
`

type GetRecipeGroupWithRecipesRow struct {
        ID          uuid.UUID      `json:"id"`
        Name        string         `json:"name"`
        Slug        string         `json:"slug"`
        Description sql.NullString `json:"description"`
        Icon        sql.NullString `json:"icon"`
        CreatedAt   sql.NullTime   `json:"created_at"`
        Recipes     interface{}    `json:"recipes"`
}

func (q *Queries) GetRecipeGroupWithRecipes(ctx context.Context, id uuid.UUID) (GetRecipeGroupWithRecipesRow, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getRecipeGroupWithRecipes, id)
        var i GetRecipeGroupWithRecipesRow
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Description,
                &amp;i.Icon,
                &amp;i.CreatedAt,
                &amp;i.Recipes,
        )
        return i, err
}</span>

const getRecipesInGroup = `-- name: GetRecipesInGroup :many
SELECT r.id, r.title, r.slug, r.markdown_content, r.author_id, r.category_id, r.description, r.prep_time_minutes, r.cook_time_minutes, r.servings, r.difficulty, r.featured_image_path, r.is_published, r.created_at, r.updated_at, r.published_at 
FROM recipes r
JOIN recipe_groupings rg ON r.id = rg.recipe_id
WHERE rg.group_id = $1
  AND r.is_published = true
ORDER BY rg.order_index
`

func (q *Queries) GetRecipesInGroup(ctx context.Context, groupID uuid.UUID) ([]Recipe, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getRecipesInGroup, groupID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Recipe
        for rows.Next() </span><span class="cov0" title="0">{
                var i Recipe
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Title,
                        &amp;i.Slug,
                        &amp;i.MarkdownContent,
                        &amp;i.AuthorID,
                        &amp;i.CategoryID,
                        &amp;i.Description,
                        &amp;i.PrepTimeMinutes,
                        &amp;i.CookTimeMinutes,
                        &amp;i.Servings,
                        &amp;i.Difficulty,
                        &amp;i.FeaturedImagePath,
                        &amp;i.IsPublished,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.PublishedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listRecipeGroups = `-- name: ListRecipeGroups :many
SELECT id, name, slug, description, icon, created_at FROM recipe_groups
ORDER BY created_at DESC
`

func (q *Queries) ListRecipeGroups(ctx context.Context) ([]RecipeGroup, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, listRecipeGroups)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []RecipeGroup
        for rows.Next() </span><span class="cov0" title="0">{
                var i RecipeGroup
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.Slug,
                        &amp;i.Description,
                        &amp;i.Icon,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const removeRecipeFromGroup = `-- name: RemoveRecipeFromGroup :exec
DELETE FROM recipe_groupings
WHERE group_id = $1 AND recipe_id = $2
`

type RemoveRecipeFromGroupParams struct {
        GroupID  uuid.UUID `json:"group_id"`
        RecipeID uuid.UUID `json:"recipe_id"`
}

func (q *Queries) RemoveRecipeFromGroup(ctx context.Context, arg RemoveRecipeFromGroupParams) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, removeRecipeFromGroup, arg.GroupID, arg.RecipeID)
        return err
}</span>

const updateRecipeGroup = `-- name: UpdateRecipeGroup :one
UPDATE recipe_groups
SET
    name = COALESCE($2, name),
    slug = COALESCE($3, slug),
    description = COALESCE($4, description),
    icon = COALESCE($5, icon)
WHERE id = $1
RETURNING id, name, slug, description, icon, created_at
`

type UpdateRecipeGroupParams struct {
        ID          uuid.UUID      `json:"id"`
        Name        sql.NullString `json:"name"`
        Slug        sql.NullString `json:"slug"`
        Description sql.NullString `json:"description"`
        Icon        sql.NullString `json:"icon"`
}

func (q *Queries) UpdateRecipeGroup(ctx context.Context, arg UpdateRecipeGroupParams) (RecipeGroup, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateRecipeGroup,
                arg.ID,
                arg.Name,
                arg.Slug,
                arg.Description,
                arg.Icon,
        )
        var i RecipeGroup
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Description,
                &amp;i.Icon,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recipe_images.sql

package sqlc

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
)

const createRecipeImage = `-- name: CreateRecipeImage :one
INSERT INTO recipe_images (recipe_id, file_path, webp_path, thumbnail_path, caption, order_index)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, recipe_id, file_path, webp_path, thumbnail_path, caption, order_index, uploaded_at
`

type CreateRecipeImageParams struct {
        RecipeID      uuid.NullUUID  `json:"recipe_id"`
        FilePath      string         `json:"file_path"`
        WebpPath      sql.NullString `json:"webp_path"`
        ThumbnailPath sql.NullString `json:"thumbnail_path"`
        Caption       sql.NullString `json:"caption"`
        OrderIndex    sql.NullInt32  `json:"order_index"`
}

func (q *Queries) CreateRecipeImage(ctx context.Context, arg CreateRecipeImageParams) (RecipeImage, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createRecipeImage,
                arg.RecipeID,
                arg.FilePath,
                arg.WebpPath,
                arg.ThumbnailPath,
                arg.Caption,
                arg.OrderIndex,
        )
        var i RecipeImage
        err := row.Scan(
                &amp;i.ID,
                &amp;i.RecipeID,
                &amp;i.FilePath,
                &amp;i.WebpPath,
                &amp;i.ThumbnailPath,
                &amp;i.Caption,
                &amp;i.OrderIndex,
                &amp;i.UploadedAt,
        )
        return i, err
}</span>

const deleteRecipeImage = `-- name: DeleteRecipeImage :exec
DELETE FROM recipe_images WHERE id = $1
`

func (q *Queries) DeleteRecipeImage(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteRecipeImage, id)
        return err
}</span>

const getRecipeImageByID = `-- name: GetRecipeImageByID :one
SELECT id, recipe_id, file_path, webp_path, thumbnail_path, caption, order_index, uploaded_at FROM recipe_images
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRecipeImageByID(ctx context.Context, id uuid.UUID) (RecipeImage, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getRecipeImageByID, id)
        var i RecipeImage
        err := row.Scan(
                &amp;i.ID,
                &amp;i.RecipeID,
                &amp;i.FilePath,
                &amp;i.WebpPath,
                &amp;i.ThumbnailPath,
                &amp;i.Caption,
                &amp;i.OrderIndex,
                &amp;i.UploadedAt,
        )
        return i, err
}</span>

const getRecipeImages = `-- name: GetRecipeImages :many
SELECT id, recipe_id, file_path, webp_path, thumbnail_path, caption, order_index, uploaded_at FROM recipe_images
WHERE recipe_id = $1
ORDER BY order_index
`

func (q *Queries) GetRecipeImages(ctx context.Context, recipeID uuid.NullUUID) ([]RecipeImage, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getRecipeImages, recipeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []RecipeImage
        for rows.Next() </span><span class="cov0" title="0">{
                var i RecipeImage
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.RecipeID,
                        &amp;i.FilePath,
                        &amp;i.WebpPath,
                        &amp;i.ThumbnailPath,
                        &amp;i.Caption,
                        &amp;i.OrderIndex,
                        &amp;i.UploadedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getRecipeWithImages = `-- name: GetRecipeWithImages :one
SELECT 
    r.id, r.title, r.slug, r.markdown_content, r.author_id, r.category_id, r.description, r.prep_time_minutes, r.cook_time_minutes, r.servings, r.difficulty, r.featured_image_path, r.is_published, r.created_at, r.updated_at, r.published_at,
    COALESCE(
        json_agg(
            json_build_object(
                'id', ri.id,
                'file_path', ri.file_path,
                'webp_path', ri.webp_path,
                'thumbnail_path', ri.thumbnail_path,
                'caption', ri.caption,
                'order_index', ri.order_index
            ) ORDER BY ri.order_index
        ) FILTER (WHERE ri.id IS NOT NULL), 
        '[]'::json
    ) as body_images
FROM recipes r
LEFT JOIN recipe_images ri ON r.id = ri.recipe_id
WHERE r.id = $1
GROUP BY r.id
`

type GetRecipeWithImagesRow struct {
        ID                uuid.UUID      `json:"id"`
        Title             string         `json:"title"`
        Slug              string         `json:"slug"`
        MarkdownContent   string         `json:"markdown_content"`
        AuthorID          uuid.NullUUID  `json:"author_id"`
        CategoryID        uuid.NullUUID  `json:"category_id"`
        Description       sql.NullString `json:"description"`
        PrepTimeMinutes   sql.NullInt32  `json:"prep_time_minutes"`
        CookTimeMinutes   sql.NullInt32  `json:"cook_time_minutes"`
        Servings          sql.NullInt32  `json:"servings"`
        Difficulty        sql.NullString `json:"difficulty"`
        FeaturedImagePath sql.NullString `json:"featured_image_path"`
        IsPublished       sql.NullBool   `json:"is_published"`
        CreatedAt         sql.NullTime   `json:"created_at"`
        UpdatedAt         sql.NullTime   `json:"updated_at"`
        PublishedAt       sql.NullTime   `json:"published_at"`
        BodyImages        interface{}    `json:"body_images"`
}

func (q *Queries) GetRecipeWithImages(ctx context.Context, id uuid.UUID) (GetRecipeWithImagesRow, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getRecipeWithImages, id)
        var i GetRecipeWithImagesRow
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Title,
                &amp;i.Slug,
                &amp;i.MarkdownContent,
                &amp;i.AuthorID,
                &amp;i.CategoryID,
                &amp;i.Description,
                &amp;i.PrepTimeMinutes,
                &amp;i.CookTimeMinutes,
                &amp;i.Servings,
                &amp;i.Difficulty,
                &amp;i.FeaturedImagePath,
                &amp;i.IsPublished,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.PublishedAt,
                &amp;i.BodyImages,
        )
        return i, err
}</span>

const updateRecipeImage = `-- name: UpdateRecipeImage :one
UPDATE recipe_images
SET
    caption = COALESCE($2, caption),
    order_index = COALESCE($3, order_index)
WHERE id = $1
RETURNING id, recipe_id, file_path, webp_path, thumbnail_path, caption, order_index, uploaded_at
`

type UpdateRecipeImageParams struct {
        ID         uuid.UUID      `json:"id"`
        Caption    sql.NullString `json:"caption"`
        OrderIndex sql.NullInt32  `json:"order_index"`
}

func (q *Queries) UpdateRecipeImage(ctx context.Context, arg UpdateRecipeImageParams) (RecipeImage, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateRecipeImage, arg.ID, arg.Caption, arg.OrderIndex)
        var i RecipeImage
        err := row.Scan(
                &amp;i.ID,
                &amp;i.RecipeID,
                &amp;i.FilePath,
                &amp;i.WebpPath,
                &amp;i.ThumbnailPath,
                &amp;i.Caption,
                &amp;i.OrderIndex,
                &amp;i.UploadedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recipes.sql

package sqlc

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
)

const createRecipe = `-- name: CreateRecipe :one
INSERT INTO recipes (id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at
`

type CreateRecipeParams struct {
        ID                uuid.UUID      `json:"id"`
        Title             string         `json:"title"`
        Slug              string         `json:"slug"`
        MarkdownContent   string         `json:"markdown_content"`
        AuthorID          uuid.NullUUID  `json:"author_id"`
        CategoryID        uuid.NullUUID  `json:"category_id"`
        Description       sql.NullString `json:"description"`
        PrepTimeMinutes   sql.NullInt32  `json:"prep_time_minutes"`
        CookTimeMinutes   sql.NullInt32  `json:"cook_time_minutes"`
        Servings          sql.NullInt32  `json:"servings"`
        Difficulty        sql.NullString `json:"difficulty"`
        FeaturedImagePath sql.NullString `json:"featured_image_path"`
        IsPublished       sql.NullBool   `json:"is_published"`
}

func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) (Recipe, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createRecipe,
                arg.ID,
                arg.Title,
                arg.Slug,
                arg.MarkdownContent,
                arg.AuthorID,
                arg.CategoryID,
                arg.Description,
                arg.PrepTimeMinutes,
                arg.CookTimeMinutes,
                arg.Servings,
                arg.Difficulty,
                arg.FeaturedImagePath,
                arg.IsPublished,
        )
        var i Recipe
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Title,
                &amp;i.Slug,
                &amp;i.MarkdownContent,
                &amp;i.AuthorID,
                &amp;i.CategoryID,
                &amp;i.Description,
                &amp;i.PrepTimeMinutes,
                &amp;i.CookTimeMinutes,
                &amp;i.Servings,
                &amp;i.Difficulty,
                &amp;i.FeaturedImagePath,
                &amp;i.IsPublished,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.PublishedAt,
        )
        return i, err
}</span>

const deleteRecipe = `-- name: DeleteRecipe :exec
DELETE FROM recipes WHERE id = $1
`

func (q *Queries) DeleteRecipe(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteRecipe, id)
        return err
}</span>

const getRecipeByID = `-- name: GetRecipeByID :one
SELECT id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at FROM recipes
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRecipeByID(ctx context.Context, id uuid.UUID) (Recipe, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getRecipeByID, id)
        var i Recipe
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Title,
                &amp;i.Slug,
                &amp;i.MarkdownContent,
                &amp;i.AuthorID,
                &amp;i.CategoryID,
                &amp;i.Description,
                &amp;i.PrepTimeMinutes,
                &amp;i.CookTimeMinutes,
                &amp;i.Servings,
                &amp;i.Difficulty,
                &amp;i.FeaturedImagePath,
                &amp;i.IsPublished,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.PublishedAt,
        )
        return i, err
}</span>

const getRecipeBySlug = `-- name: GetRecipeBySlug :one
SELECT id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at FROM recipes
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetRecipeBySlug(ctx context.Context, slug string) (Recipe, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getRecipeBySlug, slug)
        var i Recipe
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Title,
                &amp;i.Slug,
                &amp;i.MarkdownContent,
                &amp;i.AuthorID,
                &amp;i.CategoryID,
                &amp;i.Description,
                &amp;i.PrepTimeMinutes,
                &amp;i.CookTimeMinutes,
                &amp;i.Servings,
                &amp;i.Difficulty,
                &amp;i.FeaturedImagePath,
                &amp;i.IsPublished,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.PublishedAt,
        )
        return i, err
}</span>

const listRecipes = `-- name: ListRecipes :many
SELECT id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at FROM recipes
WHERE is_published = true
ORDER BY published_at DESC
LIMIT $1 OFFSET $2
`

type ListRecipesParams struct {
        Limit  int32 `json:"limit"`
        Offset int32 `json:"offset"`
}

func (q *Queries) ListRecipes(ctx context.Context, arg ListRecipesParams) ([]Recipe, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, listRecipes, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Recipe
        for rows.Next() </span><span class="cov0" title="0">{
                var i Recipe
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Title,
                        &amp;i.Slug,
                        &amp;i.MarkdownContent,
                        &amp;i.AuthorID,
                        &amp;i.CategoryID,
                        &amp;i.Description,
                        &amp;i.PrepTimeMinutes,
                        &amp;i.CookTimeMinutes,
                        &amp;i.Servings,
                        &amp;i.Difficulty,
                        &amp;i.FeaturedImagePath,
                        &amp;i.IsPublished,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.PublishedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listRecipesByAuthor = `-- name: ListRecipesByAuthor :many
SELECT id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at FROM recipes
WHERE author_id = $1
ORDER BY updated_at DESC
LIMIT $2 OFFSET $3
`

type ListRecipesByAuthorParams struct {
        AuthorID uuid.NullUUID `json:"author_id"`
        Limit    int32         `json:"limit"`
        Offset   int32         `json:"offset"`
}

func (q *Queries) ListRecipesByAuthor(ctx context.Context, arg ListRecipesByAuthorParams) ([]Recipe, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, listRecipesByAuthor, arg.AuthorID, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Recipe
        for rows.Next() </span><span class="cov0" title="0">{
                var i Recipe
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Title,
                        &amp;i.Slug,
                        &amp;i.MarkdownContent,
                        &amp;i.AuthorID,
                        &amp;i.CategoryID,
                        &amp;i.Description,
                        &amp;i.PrepTimeMinutes,
                        &amp;i.CookTimeMinutes,
                        &amp;i.Servings,
                        &amp;i.Difficulty,
                        &amp;i.FeaturedImagePath,
                        &amp;i.IsPublished,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.PublishedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const listRecipesByCategory = `-- name: ListRecipesByCategory :many
SELECT id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at FROM recipes
WHERE is_published = true
  AND category_id = $1
ORDER BY published_at DESC
LIMIT $2 OFFSET $3
`

type ListRecipesByCategoryParams struct {
        CategoryID uuid.NullUUID `json:"category_id"`
        Limit      int32         `json:"limit"`
        Offset     int32         `json:"offset"`
}

func (q *Queries) ListRecipesByCategory(ctx context.Context, arg ListRecipesByCategoryParams) ([]Recipe, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, listRecipesByCategory, arg.CategoryID, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Recipe
        for rows.Next() </span><span class="cov0" title="0">{
                var i Recipe
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Title,
                        &amp;i.Slug,
                        &amp;i.MarkdownContent,
                        &amp;i.AuthorID,
                        &amp;i.CategoryID,
                        &amp;i.Description,
                        &amp;i.PrepTimeMinutes,
                        &amp;i.CookTimeMinutes,
                        &amp;i.Servings,
                        &amp;i.Difficulty,
                        &amp;i.FeaturedImagePath,
                        &amp;i.IsPublished,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.PublishedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const searchRecipes = `-- name: SearchRecipes :many
SELECT id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at FROM recipes
WHERE is_published = true
  AND (title ILIKE '%' || $1 || '%' OR description ILIKE '%' || $1 || '%')
ORDER BY published_at DESC
LIMIT $2 OFFSET $3
`

type SearchRecipesParams struct {
        Column1 sql.NullString `json:"column_1"`
        Limit   int32          `json:"limit"`
        Offset  int32          `json:"offset"`
}

func (q *Queries) SearchRecipes(ctx context.Context, arg SearchRecipesParams) ([]Recipe, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, searchRecipes, arg.Column1, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Recipe
        for rows.Next() </span><span class="cov0" title="0">{
                var i Recipe
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Title,
                        &amp;i.Slug,
                        &amp;i.MarkdownContent,
                        &amp;i.AuthorID,
                        &amp;i.CategoryID,
                        &amp;i.Description,
                        &amp;i.PrepTimeMinutes,
                        &amp;i.CookTimeMinutes,
                        &amp;i.Servings,
                        &amp;i.Difficulty,
                        &amp;i.FeaturedImagePath,
                        &amp;i.IsPublished,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                        &amp;i.PublishedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateRecipe = `-- name: UpdateRecipe :one
UPDATE recipes
SET
    title = COALESCE($2, title),
    markdown_content = COALESCE($3, markdown_content),
    category_id = COALESCE($4, category_id),
    description = COALESCE($5, description),
    prep_time_minutes = COALESCE($6, prep_time_minutes),
    cook_time_minutes = COALESCE($7, cook_time_minutes),
    servings = COALESCE($8, servings),
    difficulty = COALESCE($9, difficulty),
    featured_image_path = COALESCE($10, featured_image_path),
    is_published = COALESCE($11, is_published),
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at
`

type UpdateRecipeParams struct {
        ID                uuid.UUID      `json:"id"`
        Title             sql.NullString `json:"title"`
        MarkdownContent   sql.NullString `json:"markdown_content"`
        CategoryID        uuid.NullUUID  `json:"category_id"`
        Description       sql.NullString `json:"description"`
        PrepTimeMinutes   sql.NullInt32  `json:"prep_time_minutes"`
        CookTimeMinutes   sql.NullInt32  `json:"cook_time_minutes"`
        Servings          sql.NullInt32  `json:"servings"`
        Difficulty        sql.NullString `json:"difficulty"`
        FeaturedImagePath sql.NullString `json:"featured_image_path"`
        IsPublished       sql.NullBool   `json:"is_published"`
}

func (q *Queries) UpdateRecipe(ctx context.Context, arg UpdateRecipeParams) (Recipe, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateRecipe,
                arg.ID,
                arg.Title,
                arg.MarkdownContent,
                arg.CategoryID,
                arg.Description,
                arg.PrepTimeMinutes,
                arg.CookTimeMinutes,
                arg.Servings,
                arg.Difficulty,
                arg.FeaturedImagePath,
                arg.IsPublished,
        )
        var i Recipe
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Title,
                &amp;i.Slug,
                &amp;i.MarkdownContent,
                &amp;i.AuthorID,
                &amp;i.CategoryID,
                &amp;i.Description,
                &amp;i.PrepTimeMinutes,
                &amp;i.CookTimeMinutes,
                &amp;i.Servings,
                &amp;i.Difficulty,
                &amp;i.FeaturedImagePath,
                &amp;i.IsPublished,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.PublishedAt,
        )
        return i, err
}</span>

const updateRecipeFeaturedImage = `-- name: UpdateRecipeFeaturedImage :one
UPDATE recipes
SET
    featured_image_path = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at
`

type UpdateRecipeFeaturedImageParams struct {
        ID                uuid.UUID      `json:"id"`
        FeaturedImagePath sql.NullString `json:"featured_image_path"`
}

func (q *Queries) UpdateRecipeFeaturedImage(ctx context.Context, arg UpdateRecipeFeaturedImageParams) (Recipe, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateRecipeFeaturedImage, arg.ID, arg.FeaturedImagePath)
        var i Recipe
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Title,
                &amp;i.Slug,
                &amp;i.MarkdownContent,
                &amp;i.AuthorID,
                &amp;i.CategoryID,
                &amp;i.Description,
                &amp;i.PrepTimeMinutes,
                &amp;i.CookTimeMinutes,
                &amp;i.Servings,
                &amp;i.Difficulty,
                &amp;i.FeaturedImagePath,
                &amp;i.IsPublished,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.PublishedAt,
        )
        return i, err
}</span>

const updateRecipePublishedStatus = `-- name: UpdateRecipePublishedStatus :one
UPDATE recipes
SET
    is_published = $2,
    published_at = CASE WHEN $2 = true THEN NOW() ELSE published_at END,
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at
`

type UpdateRecipePublishedStatusParams struct {
        ID          uuid.UUID    `json:"id"`
        IsPublished sql.NullBool `json:"is_published"`
}

func (q *Queries) UpdateRecipePublishedStatus(ctx context.Context, arg UpdateRecipePublishedStatusParams) (Recipe, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateRecipePublishedStatus, arg.ID, arg.IsPublished)
        var i Recipe
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Title,
                &amp;i.Slug,
                &amp;i.MarkdownContent,
                &amp;i.AuthorID,
                &amp;i.CategoryID,
                &amp;i.Description,
                &amp;i.PrepTimeMinutes,
                &amp;i.CookTimeMinutes,
                &amp;i.Servings,
                &amp;i.Difficulty,
                &amp;i.FeaturedImagePath,
                &amp;i.IsPublished,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
                &amp;i.PublishedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: settings.sql

package sqlc

import (
        "context"
        "encoding/json"
)

const deleteSetting = `-- name: DeleteSetting :exec
DELETE FROM app_settings WHERE key = $1
`

func (q *Queries) DeleteSetting(ctx context.Context, key string) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteSetting, key)
        return err
}</span>

const getSetting = `-- name: GetSetting :one
SELECT key, value, updated_at FROM app_settings
WHERE key = $1 LIMIT 1
`

func (q *Queries) GetSetting(ctx context.Context, key string) (AppSetting, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getSetting, key)
        var i AppSetting
        err := row.Scan(&amp;i.Key, &amp;i.Value, &amp;i.UpdatedAt)
        return i, err
}</span>

const listSettings = `-- name: ListSettings :many
SELECT key, value, updated_at FROM app_settings
ORDER BY key
`

func (q *Queries) ListSettings(ctx context.Context) ([]AppSetting, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, listSettings)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []AppSetting
        for rows.Next() </span><span class="cov0" title="0">{
                var i AppSetting
                if err := rows.Scan(&amp;i.Key, &amp;i.Value, &amp;i.UpdatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const upsertSetting = `-- name: UpsertSetting :one
INSERT INTO app_settings (key, value, updated_at)
VALUES ($1, $2, NOW())
ON CONFLICT (key) DO UPDATE SET
    value = EXCLUDED.value,
    updated_at = NOW()
RETURNING key, value, updated_at
`

type UpsertSettingParams struct {
        Key   string          `json:"key"`
        Value json.RawMessage `json:"value"`
}

func (q *Queries) UpsertSetting(ctx context.Context, arg UpsertSettingParams) (AppSetting, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, upsertSetting, arg.Key, arg.Value)
        var i AppSetting
        err := row.Scan(&amp;i.Key, &amp;i.Value, &amp;i.UpdatedAt)
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: share_codes.sql

package sqlc

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
)

const createShareCode = `-- name: CreateShareCode :one
INSERT INTO share_codes (recipe_id, code, expires_at, max_uses)
VALUES ($1, $2, $3, $4)
RETURNING id, recipe_id, code, expires_at, max_uses, use_count, created_at
`

type CreateShareCodeParams struct {
        RecipeID  uuid.NullUUID `json:"recipe_id"`
        Code      string        `json:"code"`
        ExpiresAt sql.NullTime  `json:"expires_at"`
        MaxUses   sql.NullInt32 `json:"max_uses"`
}

func (q *Queries) CreateShareCode(ctx context.Context, arg CreateShareCodeParams) (ShareCode, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createShareCode,
                arg.RecipeID,
                arg.Code,
                arg.ExpiresAt,
                arg.MaxUses,
        )
        var i ShareCode
        err := row.Scan(
                &amp;i.ID,
                &amp;i.RecipeID,
                &amp;i.Code,
                &amp;i.ExpiresAt,
                &amp;i.MaxUses,
                &amp;i.UseCount,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const deleteShareCode = `-- name: DeleteShareCode :exec
DELETE FROM share_codes WHERE id = $1
`

func (q *Queries) DeleteShareCode(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteShareCode, id)
        return err
}</span>

const getShareCodeByCode = `-- name: GetShareCodeByCode :one
SELECT sc.id, sc.recipe_id, sc.code, sc.expires_at, sc.max_uses, sc.use_count, sc.created_at, r.title as recipe_title, r.slug as recipe_slug
FROM share_codes sc
JOIN recipes r ON sc.recipe_id = r.id
WHERE sc.code = $1
  AND (sc.expires_at IS NULL OR sc.expires_at &gt; NOW())
  AND (sc.max_uses IS NULL OR sc.use_count &lt; sc.max_uses)
LIMIT 1
`

type GetShareCodeByCodeRow struct {
        ID          uuid.UUID     `json:"id"`
        RecipeID    uuid.NullUUID `json:"recipe_id"`
        Code        string        `json:"code"`
        ExpiresAt   sql.NullTime  `json:"expires_at"`
        MaxUses     sql.NullInt32 `json:"max_uses"`
        UseCount    sql.NullInt32 `json:"use_count"`
        CreatedAt   sql.NullTime  `json:"created_at"`
        RecipeTitle string        `json:"recipe_title"`
        RecipeSlug  string        `json:"recipe_slug"`
}

func (q *Queries) GetShareCodeByCode(ctx context.Context, code string) (GetShareCodeByCodeRow, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getShareCodeByCode, code)
        var i GetShareCodeByCodeRow
        err := row.Scan(
                &amp;i.ID,
                &amp;i.RecipeID,
                &amp;i.Code,
                &amp;i.ExpiresAt,
                &amp;i.MaxUses,
                &amp;i.UseCount,
                &amp;i.CreatedAt,
                &amp;i.RecipeTitle,
                &amp;i.RecipeSlug,
        )
        return i, err
}</span>

const getShareCodesForRecipe = `-- name: GetShareCodesForRecipe :many
SELECT id, recipe_id, code, expires_at, max_uses, use_count, created_at FROM share_codes
WHERE recipe_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetShareCodesForRecipe(ctx context.Context, recipeID uuid.NullUUID) ([]ShareCode, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getShareCodesForRecipe, recipeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []ShareCode
        for rows.Next() </span><span class="cov0" title="0">{
                var i ShareCode
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.RecipeID,
                        &amp;i.Code,
                        &amp;i.ExpiresAt,
                        &amp;i.MaxUses,
                        &amp;i.UseCount,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const incrementShareCodeUse = `-- name: IncrementShareCodeUse :exec
UPDATE share_codes
SET use_count = use_count + 1
WHERE id = $1
`

func (q *Queries) IncrementShareCodeUse(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, incrementShareCodeUse, id)
        return err
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tags.sql

package sqlc

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
)

const addTagToRecipe = `-- name: AddTagToRecipe :exec
INSERT INTO recipe_tags (recipe_id, tag_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AddTagToRecipeParams struct {
        RecipeID uuid.UUID `json:"recipe_id"`
        TagID    uuid.UUID `json:"tag_id"`
}

func (q *Queries) AddTagToRecipe(ctx context.Context, arg AddTagToRecipeParams) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, addTagToRecipe, arg.RecipeID, arg.TagID)
        return err
}</span>

const createTag = `-- name: CreateTag :one
INSERT INTO tags (id, name, slug, color)
VALUES ($1, $2, $3, $4)
RETURNING id, name, slug, color, created_at
`

type CreateTagParams struct {
        ID    uuid.UUID      `json:"id"`
        Name  string         `json:"name"`
        Slug  string         `json:"slug"`
        Color sql.NullString `json:"color"`
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) (Tag, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createTag,
                arg.ID,
                arg.Name,
                arg.Slug,
                arg.Color,
        )
        var i Tag
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Color,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags WHERE id = $1
`

func (q *Queries) DeleteTag(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteTag, id)
        return err
}</span>

const getRecipeTags = `-- name: GetRecipeTags :many
SELECT t.id, t.name, t.slug, t.color, t.created_at FROM tags t
JOIN recipe_tags rt ON t.id = rt.tag_id
WHERE rt.recipe_id = $1
`

func (q *Queries) GetRecipeTags(ctx context.Context, recipeID uuid.UUID) ([]Tag, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, getRecipeTags, recipeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Tag
        for rows.Next() </span><span class="cov0" title="0">{
                var i Tag
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.Slug,
                        &amp;i.Color,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const getTagByID = `-- name: GetTagByID :one
SELECT id, name, slug, color, created_at FROM tags
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTagByID(ctx context.Context, id uuid.UUID) (Tag, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getTagByID, id)
        var i Tag
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Color,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const getTagBySlug = `-- name: GetTagBySlug :one
SELECT id, name, slug, color, created_at FROM tags
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetTagBySlug(ctx context.Context, slug string) (Tag, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getTagBySlug, slug)
        var i Tag
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Color,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const listTags = `-- name: ListTags :many
SELECT id, name, slug, color, created_at FROM tags
ORDER BY name ASC
`

func (q *Queries) ListTags(ctx context.Context) ([]Tag, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, listTags)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []Tag
        for rows.Next() </span><span class="cov0" title="0">{
                var i Tag
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Name,
                        &amp;i.Slug,
                        &amp;i.Color,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const removeTagFromRecipe = `-- name: RemoveTagFromRecipe :exec
DELETE FROM recipe_tags
WHERE recipe_id = $1 AND tag_id = $2
`

type RemoveTagFromRecipeParams struct {
        RecipeID uuid.UUID `json:"recipe_id"`
        TagID    uuid.UUID `json:"tag_id"`
}

func (q *Queries) RemoveTagFromRecipe(ctx context.Context, arg RemoveTagFromRecipeParams) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, removeTagFromRecipe, arg.RecipeID, arg.TagID)
        return err
}</span>

const updateTag = `-- name: UpdateTag :one
UPDATE tags
SET
    name = COALESCE($2, name),
    slug = COALESCE($3, slug),
    color = COALESCE($4, color)
WHERE id = $1
RETURNING id, name, slug, color, created_at
`

type UpdateTagParams struct {
        ID    uuid.UUID      `json:"id"`
        Name  sql.NullString `json:"name"`
        Slug  sql.NullString `json:"slug"`
        Color sql.NullString `json:"color"`
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) (Tag, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateTag,
                arg.ID,
                arg.Name,
                arg.Slug,
                arg.Color,
        )
        var i Tag
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Name,
                &amp;i.Slug,
                &amp;i.Color,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_invites.sql

package sqlc

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
)

const createUserInvite = `-- name: CreateUserInvite :one
INSERT INTO user_invites (code, email, role, created_by, expires_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, code, email, role, created_by, expires_at, used_at, used_by, created_at
`

type CreateUserInviteParams struct {
        Code      string         `json:"code"`
        Email     sql.NullString `json:"email"`
        Role      sql.NullString `json:"role"`
        CreatedBy uuid.NullUUID  `json:"created_by"`
        ExpiresAt sql.NullTime   `json:"expires_at"`
}

func (q *Queries) CreateUserInvite(ctx context.Context, arg CreateUserInviteParams) (UserInvite, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createUserInvite,
                arg.Code,
                arg.Email,
                arg.Role,
                arg.CreatedBy,
                arg.ExpiresAt,
        )
        var i UserInvite
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Code,
                &amp;i.Email,
                &amp;i.Role,
                &amp;i.CreatedBy,
                &amp;i.ExpiresAt,
                &amp;i.UsedAt,
                &amp;i.UsedBy,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const deleteInvite = `-- name: DeleteInvite :exec
DELETE FROM user_invites WHERE id = $1
`

func (q *Queries) DeleteInvite(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteInvite, id)
        return err
}</span>

const getInviteByCode = `-- name: GetInviteByCode :one
SELECT id, code, email, role, created_by, expires_at, used_at, used_by, created_at FROM user_invites
WHERE code = $1
  AND (expires_at IS NULL OR expires_at &gt; NOW())
  AND used_at IS NULL
LIMIT 1
`

func (q *Queries) GetInviteByCode(ctx context.Context, code string) (UserInvite, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getInviteByCode, code)
        var i UserInvite
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Code,
                &amp;i.Email,
                &amp;i.Role,
                &amp;i.CreatedBy,
                &amp;i.ExpiresAt,
                &amp;i.UsedAt,
                &amp;i.UsedBy,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>

const listInvites = `-- name: ListInvites :many
SELECT id, code, email, role, created_by, expires_at, used_at, used_by, created_at FROM user_invites
ORDER BY created_at DESC
`

func (q *Queries) ListInvites(ctx context.Context) ([]UserInvite, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, listInvites)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []UserInvite
        for rows.Next() </span><span class="cov0" title="0">{
                var i UserInvite
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Code,
                        &amp;i.Email,
                        &amp;i.Role,
                        &amp;i.CreatedBy,
                        &amp;i.ExpiresAt,
                        &amp;i.UsedAt,
                        &amp;i.UsedBy,
                        &amp;i.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const useInvite = `-- name: UseInvite :one
UPDATE user_invites
SET
    used_at = NOW(),
    used_by = $2
WHERE id = $1
RETURNING id, code, email, role, created_by, expires_at, used_at, used_by, created_at
`

type UseInviteParams struct {
        ID     uuid.UUID     `json:"id"`
        UsedBy uuid.NullUUID `json:"used_by"`
}

func (q *Queries) UseInvite(ctx context.Context, arg UseInviteParams) (UserInvite, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, useInvite, arg.ID, arg.UsedBy)
        var i UserInvite
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Code,
                &amp;i.Email,
                &amp;i.Role,
                &amp;i.CreatedBy,
                &amp;i.ExpiresAt,
                &amp;i.UsedAt,
                &amp;i.UsedBy,
                &amp;i.CreatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package sqlc

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password_hash, role)
VALUES ($1, $2, $3)
RETURNING id, email, password_hash, role, created_at, updated_at
`

type CreateUserParams struct {
        Email        string `json:"email"`
        PasswordHash string `json:"password_hash"`
        Role         string `json:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, createUser, arg.Email, arg.PasswordHash, arg.Role)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.PasswordHash,
                &amp;i.Role,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error <span class="cov0" title="0">{
        _, err := q.db.ExecContext(ctx, deleteUser, id)
        return err
}</span>

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, role, created_at, updated_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getUserByEmail, email)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.PasswordHash,
                &amp;i.Role,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, role, created_at, updated_at FROM users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, getUserByID, id)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.PasswordHash,
                &amp;i.Role,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>

const listUsers = `-- name: ListUsers :many
SELECT id, email, password_hash, role, created_at, updated_at FROM users
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
        Limit  int32 `json:"limit"`
        Offset int32 `json:"offset"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) <span class="cov0" title="0">{
        rows, err := q.db.QueryContext(ctx, listUsers, arg.Limit, arg.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        var items []User
        for rows.Next() </span><span class="cov0" title="0">{
                var i User
                if err := rows.Scan(
                        &amp;i.ID,
                        &amp;i.Email,
                        &amp;i.PasswordHash,
                        &amp;i.Role,
                        &amp;i.CreatedAt,
                        &amp;i.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">items = append(items, i)</span>
        }
        <span class="cov0" title="0">if err := rows.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return items, nil</span>
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET
    email = COALESCE($2, email),
    role = COALESCE($3, role),
    updated_at = NOW()
WHERE id = $1
RETURNING id, email, password_hash, role, created_at, updated_at
`

type UpdateUserParams struct {
        ID    uuid.UUID      `json:"id"`
        Email sql.NullString `json:"email"`
        Role  sql.NullString `json:"role"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) <span class="cov0" title="0">{
        row := q.db.QueryRowContext(ctx, updateUser, arg.ID, arg.Email, arg.Role)
        var i User
        err := row.Scan(
                &amp;i.ID,
                &amp;i.Email,
                &amp;i.PasswordHash,
                &amp;i.Role,
                &amp;i.CreatedAt,
                &amp;i.UpdatedAt,
        )
        return i, err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"

        "github.com/homecooking/backend/internal/models"
        "github.com/homecooking/backend/internal/services"
)

type AuthHandler struct {
        authService *services.AuthService
}

func NewAuthHandler(authService *services.AuthService) *AuthHandler <span class="cov8" title="1">{
        return &amp;AuthHandler{
                authService: authService,
        }
}</span>

func (h *AuthHandler) Register(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req models.RegisterRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if req.Email == "" || req.Password == "" </span><span class="cov8" title="1">{
                http.Error(w, "Email and password are required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">user, err := h.authService.Register(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to register user", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)</span>
}

func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req models.LoginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if req.Email == "" || req.Password == "" </span><span class="cov8" title="1">{
                http.Error(w, "Email and password are required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">tokens, err := h.authService.Login(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(tokens)</span>
}

func (h *AuthHandler) Refresh(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var req struct {
                RefreshToken string `json:"refresh_token"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov8" title="1">if req.RefreshToken == "" </span><span class="cov8" title="1">{
                http.Error(w, "Refresh token is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">tokens, err := h.authService.RefreshToken(req.RefreshToken)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid refresh token", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(tokens)</span>
}

func (h *AuthHandler) Me(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        user := r.Context().Value("user").(*models.User)
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(user)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"

        "github.com/homecooking/backend/internal/models"
        "github.com/homecooking/backend/internal/services"
)

type CategoryHandler struct {
        categoryService *services.CategoryService
}

func NewCategoryHandler(categoryService *services.CategoryService) *CategoryHandler <span class="cov0" title="0">{
        return &amp;CategoryHandler{
                categoryService: categoryService,
        }
}</span>

func (h *CategoryHandler) ListCategories(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        categories, err := h.categoryService.ListCategories()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to fetch categories", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(categories)</span>
}

func (h *CategoryHandler) GetCategory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")
        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, "Category ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">category, err := h.categoryService.GetCategory(id)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Category not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(category)</span>
}

func (h *CategoryHandler) CreateCategory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req models.Category
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">category, err := h.categoryService.CreateCategory(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(category)</span>
}

func (h *CategoryHandler) UpdateCategory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")
        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, "Category ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req models.Category
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">category, err := h.categoryService.UpdateCategory(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(category)</span>
}

func (h *CategoryHandler) DeleteCategory(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")
        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, "Category ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := h.categoryService.DeleteCategory(id)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Category not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"

        "github.com/homecooking/backend/internal/models"
        "github.com/homecooking/backend/internal/services"
)

type RecipeGroupHandler struct {
        service *services.RecipeGroupService
}

func NewRecipeGroupHandler(service *services.RecipeGroupService) *RecipeGroupHandler <span class="cov0" title="0">{
        return &amp;RecipeGroupHandler{
                service: service,
        }
}</span>

func (h *RecipeGroupHandler) ListGroups(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        groups, err := h.service.List()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "groups": groups,
        })</span>
}

func (h *RecipeGroupHandler) GetGroup(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")
        group, err := h.service.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(group)</span>
}

func (h *RecipeGroupHandler) CreateGroup(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req struct {
                Name        string  `json:"name"`
                Description *string `json:"description"`
                Icon        *string `json:"icon"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.Name == "" </span><span class="cov0" title="0">{
                http.Error(w, "name is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">group := &amp;models.RecipeGroup{
                Name:        req.Name,
                Description: req.Description,
                Icon:        req.Icon,
        }

        createdGroup, err := h.service.Create(group)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(createdGroup)</span>
}

func (h *RecipeGroupHandler) UpdateGroup(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")
        var group models.RecipeGroup

        if err := json.NewDecoder(r.Body).Decode(&amp;group); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">updatedGroup, err := h.service.Update(id, &amp;group)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(updatedGroup)</span>
}

func (h *RecipeGroupHandler) DeleteGroup(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")

        if err := h.service.Delete(id); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
        })</span>
}

func (h *RecipeGroupHandler) GetGroupRecipes(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")
        recipes, err := h.service.GetRecipesInGroup(id)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "recipes": recipes,
        })</span>
}

func (h *RecipeGroupHandler) AddRecipeToGroup(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        groupID := r.PathValue("id")
        var req struct {
                RecipeID string `json:"recipe_id"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if req.RecipeID == "" </span><span class="cov0" title="0">{
                http.Error(w, "recipe_id is required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.AddRecipeToGroup(groupID, req.RecipeID); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
        })</span>
}

func (h *RecipeGroupHandler) RemoveRecipeFromGroup(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        groupID := r.PathValue("id")
        recipeID := r.PathValue("recipeId")

        if err := h.service.RemoveRecipeFromGroup(groupID, recipeID); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "success": true,
        })</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
        "strconv"

        "github.com/homecooking/backend/internal/models"
        "github.com/homecooking/backend/internal/services"
)

type RecipeHandler struct {
        recipeService *services.RecipeService
}

func NewRecipeHandler(recipeService *services.RecipeService) *RecipeHandler <span class="cov0" title="0">{
        return &amp;RecipeHandler{
                recipeService: recipeService,
        }
}</span>

func (h *RecipeHandler) ListRecipes(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")

        limit := 20
        offset := 0

        if limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">if offsetStr != "" </span><span class="cov0" title="0">{
                if o, err := strconv.Atoi(offsetStr); err == nil </span><span class="cov0" title="0">{
                        offset = o
                }</span>
        }

        <span class="cov0" title="0">recipes, err := h.recipeService.ListRecipes(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to fetch recipes", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(recipes)</span>
}

func (h *RecipeHandler) GetRecipe(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")
        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, "Recipe ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">recipe, err := h.recipeService.GetRecipe(id)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Recipe not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(recipe)</span>
}

func (h *RecipeHandler) GetRecipeBySlug(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        slug := r.PathValue("slug")
        if slug == "" </span><span class="cov0" title="0">{
                http.Error(w, "Slug required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">recipe, err := h.recipeService.GetRecipeBySlug(slug)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Recipe not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(recipe)</span>
}

func (h *RecipeHandler) CreateRecipe(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req models.CreateRecipeRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">user := r.Context().Value("user").(*models.User)

        recipe, err := h.recipeService.CreateRecipe(&amp;req, user.ID.String())
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(recipe)</span>
}

func (h *RecipeHandler) UpdateRecipe(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")
        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, "Recipe ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateRecipeRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">user := r.Context().Value("user").(*models.User)

        recipe, err := h.recipeService.UpdateRecipe(id, &amp;req, user.ID.String())
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "unauthorized: you can only edit your own recipes" </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusForbidden)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(recipe)</span>
}

func (h *RecipeHandler) DeleteRecipe(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")
        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, "Recipe ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">user := r.Context().Value("user").(*models.User)

        err := h.recipeService.DeleteRecipe(id, user.ID.String())
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "unauthorized: you can only delete your own recipes" </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusForbidden)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Recipe not found", http.StatusNotFound)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *RecipeHandler) PublishRecipe(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")
        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, "Recipe ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Published bool `json:"published"`
        }
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">user := r.Context().Value("user").(*models.User)

        recipe, err := h.recipeService.PublishRecipe(id, user.ID.String(), req.Published)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "unauthorized: you can only publish your own recipes" </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusForbidden)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Recipe not found", http.StatusNotFound)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(recipe)</span>
}

func (h *RecipeHandler) SearchRecipes(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        query := r.URL.Query().Get("q")
        if query == "" </span><span class="cov0" title="0">{
                http.Error(w, "Query required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">limitStr := r.URL.Query().Get("limit")
        offsetStr := r.URL.Query().Get("offset")

        limit := 20
        offset := 0

        if limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">if offsetStr != "" </span><span class="cov0" title="0">{
                if o, err := strconv.Atoi(offsetStr); err == nil </span><span class="cov0" title="0">{
                        offset = o
                }</span>
        }

        <span class="cov0" title="0">recipes, err := h.recipeService.SearchRecipes(query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to search recipes", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(recipes)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"

        "github.com/homecooking/backend/internal/models"
        "github.com/homecooking/backend/internal/services"
)

type TagHandler struct {
        tagService *services.TagService
}

func NewTagHandler(tagService *services.TagService) *TagHandler <span class="cov0" title="0">{
        return &amp;TagHandler{
                tagService: tagService,
        }
}</span>

func (h *TagHandler) ListTags(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tags, err := h.tagService.ListTags()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to fetch tags", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(tags)</span>
}

func (h *TagHandler) GetTag(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")
        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, "Tag ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">tag, err := h.tagService.GetTag(id)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Tag not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(tag)</span>
}

func (h *TagHandler) CreateTag(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req models.Tag
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">tag, err := h.tagService.CreateTag(&amp;req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(tag)</span>
}

func (h *TagHandler) UpdateTag(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")
        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, "Tag ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">var req models.Tag
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Invalid request body", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">tag, err := h.tagService.UpdateTag(id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(tag)</span>
}

func (h *TagHandler) DeleteTag(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := r.PathValue("id")
        if id == "" </span><span class="cov0" title="0">{
                http.Error(w, "Tag ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := h.tagService.DeleteTag(id)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Tag not found", http.StatusNotFound)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *TagHandler) GetRecipeTags(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        recipeID := r.PathValue("recipeId")
        if recipeID == "" </span><span class="cov0" title="0">{
                http.Error(w, "Recipe ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">tags, err := h.tagService.GetRecipeTags(recipeID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to fetch recipe tags", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(tags)</span>
}

func (h *TagHandler) AddTagToRecipe(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        recipeID := r.PathValue("recipeId")
        tagID := r.PathValue("tagId")

        if recipeID == "" || tagID == "" </span><span class="cov0" title="0">{
                http.Error(w, "Recipe ID and Tag ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := h.tagService.AddTagToRecipe(recipeID, tagID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusCreated)</span>
}

func (h *TagHandler) RemoveTagFromRecipe(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        recipeID := r.PathValue("recipeId")
        tagID := r.PathValue("tagId")

        if recipeID == "" || tagID == "" </span><span class="cov0" title="0">{
                http.Error(w, "Recipe ID and Tag ID required", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">err := h.tagService.RemoveTagFromRecipe(recipeID, tagID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "log"
        "net/http"

        "github.com/homecooking/backend/internal/services"
)

type UploadHandler struct {
        storage *services.StorageService
}

func NewUploadHandler(storage *services.StorageService) *UploadHandler <span class="cov0" title="0">{
        return &amp;UploadHandler{
                storage: storage,
        }
}</span>

type UploadResponse struct {
        Success  bool   `json:"success"`
        Filename string `json:"filename,omitempty"`
        URL      string `json:"url,omitempty"`
        Error    string `json:"error,omitempty"`
}

func (h *UploadHandler) UploadImage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">err := r.ParseMultipartForm(32 &lt;&lt; 20)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to parse form: %v", err)
                sendError(w, "Failed to parse form", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">file, header, err := r.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to get file: %v", err)
                sendError(w, "No file provided", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        if header.Size == 0 </span><span class="cov0" title="0">{
                sendError(w, "Empty file", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">contentType := header.Header.Get("Content-Type")
        if contentType == "" </span><span class="cov0" title="0">{
                buffer := make([]byte, 512)
                file.Read(buffer)
                file.Seek(0, 0)
                contentType = http.DetectContentType(buffer)
        }</span>

        <span class="cov0" title="0">if !isValidImageType(contentType) </span><span class="cov0" title="0">{
                sendError(w, "Invalid file type. Only JPEG, PNG, GIF, and WebP are allowed", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">filename, err := h.storage.SaveImage(header, "recipe")
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to save image: %v", err)
                sendError(w, "Failed to save image", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">response := UploadResponse{
                Success:  true,
                Filename: filename,
                URL:      fmt.Sprintf("/uploads/%s", filename),
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

func isValidImageType(contentType string) bool <span class="cov0" title="0">{
        validTypes := map[string]bool{
                "image/jpeg": true,
                "image/png":  true,
                "image/gif":  true,
                "image/webp": true,
        }
        return validTypes[contentType]
}</span>

func sendError(w http.ResponseWriter, message string, statusCode int) <span class="cov0" title="0">{
        w.WriteHeader(statusCode)
        json.NewEncoder(w).Encode(UploadResponse{
                Success: false,
                Error:   message,
        })
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package integration

import (
        "bytes"
        "database/sql"
        "encoding/json"
        "net/http"
        "net/http/httptest"
        "testing"

        "github.com/google/uuid"
        "github.com/homecooking/backend/internal/config"
        "github.com/homecooking/backend/internal/db/sqlc"
        "github.com/homecooking/backend/internal/handlers"
        "github.com/homecooking/backend/internal/repository"
        "github.com/homecooking/backend/internal/services"
        testutil "github.com/homecooking/backend/internal/testing"
        _ "github.com/mattn/go-sqlite3"
        "github.com/stretchr/testify/require"
        "golang.org/x/crypto/bcrypt"
)

type TestServer struct {
        DB          *sql.DB
        Queries     *sqlc.Queries
        Config      *config.Config
        UserRepo    *repository.UserRepository
        AuthHandler *handlers.AuthHandler
        AuthService *services.AuthService
}

// SetupTestServer creates a test server with minimal setup for integration tests
func SetupTestServer(t *testing.T) *TestServer <span class="cov8" title="1">{
        // Create in-memory database
        db, q, err := testutil.SetupTestDB()
        require.NoError(t, err)

        // Initialize config
        cfg := &amp;config.Config{
                Auth: config.AuthConfig{
                        JWTSecret:        "test-secret-key-for-integration-tests",
                        RefreshSecret:    "test-refresh-secret-for-integration-tests",
                        TokenExpiryHours: 1,
                },
        }

        // Initialize repositories and services
        userRepo := repository.NewUserRepository(db, q)
        authService := services.NewAuthService(cfg, userRepo)
        authHandler := handlers.NewAuthHandler(authService)

        return &amp;TestServer{
                DB:          db,
                Queries:     q,
                Config:      cfg,
                UserRepo:    userRepo,
                AuthHandler: authHandler,
                AuthService: authService,
        }
}</span>

// TeardownTestServer closes the test server resources
func TeardownTestServer(server *TestServer) <span class="cov8" title="1">{
        if server.DB != nil </span><span class="cov8" title="1">{
                server.DB.Close()
        }</span>
}

// createTestUserDirect creates a test user using raw SQL (bypasses repository issues)
func createTestUserDirect(t *testing.T, server *TestServer, email, password string) string <span class="cov8" title="1">{
        userID := uuid.New().String()
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        require.NoError(t, err)

        _, err = server.DB.Exec(`
                INSERT INTO users (id, email, password_hash, role, created_at, updated_at)
                VALUES (?, ?, ?, ?, datetime('now'), datetime('now'))
        `, userID, email, string(hashedPassword), "user")

        require.NoError(t, err)
        return userID
}</span>

// CreateTestUser creates a test user and returns an auth token
func CreateTestUser(t *testing.T, server *TestServer, email, password string) string <span class="cov0" title="0">{
        // Register user
        registerBody := map[string]string{
                "email":    email,
                "password": password,
        }
        registerBodyBytes, _ := json.Marshal(registerBody)

        req := httptest.NewRequest("POST", "/api/v1/auth/register", bytes.NewReader(registerBodyBytes))
        req.Header.Set("Content-Type", "application/json")
        w := httptest.NewRecorder()

        server.AuthHandler.Register(w, req)

        require.Equal(t, http.StatusCreated, w.Code, "Failed to register user: %s", w.Body.String())

        // Login to get token
        loginBody := map[string]string{
                "email":    email,
                "password": password,
        }
        loginBodyBytes, _ := json.Marshal(loginBody)

        req = httptest.NewRequest("POST", "/api/v1/auth/login", bytes.NewReader(loginBodyBytes))
        req.Header.Set("Content-Type", "application/json")
        w = httptest.NewRecorder()

        server.AuthHandler.Login(w, req)

        require.Equal(t, http.StatusOK, w.Code, "Failed to login user: %s", w.Body.String())

        var response map[string]interface{}
        err := json.Unmarshal(w.Body.Bytes(), &amp;response)
        require.NoError(t, err)

        token, ok := response["access_token"].(string)
        require.True(t, ok, "No access_token in response")
        require.NotEmpty(t, token, "Token is empty")

        return token
}</span>

// MakeAuthenticatedRequest creates an HTTP request with auth token
func MakeAuthenticatedRequest(method, url string, body interface{}, token string) *http.Request <span class="cov0" title="0">{
        var bodyReader *bytes.Reader
        if body != nil </span><span class="cov0" title="0">{
                bodyBytes, err := json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">bodyReader = bytes.NewReader(bodyBytes)</span>
        }

        <span class="cov0" title="0">req := httptest.NewRequest(method, url, bodyReader)
        if body != nil </span><span class="cov0" title="0">{
                req.Header.Set("Content-Type", "application/json")
        }</span>

        <span class="cov0" title="0">if token != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+token)
        }</span>

        <span class="cov0" title="0">return req</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package middleware

import (
        "context"
        "log"
        "net/http"
        "strings"

        "github.com/homecooking/backend/internal/models"
)

type contextKey string

const (
        UserKey contextKey = "user"
)

type AuthMiddleware struct {
        authService AuthService
}

type AuthService interface {
        ValidateToken(token string) (*models.User, error)
}

func NewAuthMiddleware(authService AuthService) *AuthMiddleware <span class="cov8" title="1">{
        return &amp;AuthMiddleware{
                authService: authService,
        }
}</span>

func (m *AuthMiddleware) Auth(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov8" title="1">{
                        http.Error(w, "Authorization header required", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov8" title="1">{
                        http.Error(w, "Invalid authorization header format", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">token := strings.TrimPrefix(authHeader, "Bearer ")
                user, err := m.authService.ValidateToken(token)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Token validation failed: %v", err)
                        http.Error(w, "Invalid token", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov8" title="1">ctx := context.WithValue(r.Context(), UserKey, user)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

func (m *AuthMiddleware) RequireRole(roles ...string) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        user, ok := r.Context().Value(UserKey).(*models.User)
                        if !ok </span><span class="cov0" title="0">{
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                                return
                        }</span>

                        <span class="cov8" title="1">hasRole := false
                        for _, role := range roles </span><span class="cov8" title="1">{
                                if user.Role == role </span><span class="cov8" title="1">{
                                        hasRole = true
                                        break</span>
                                }
                        }

                        <span class="cov8" title="1">if !hasRole </span><span class="cov8" title="1">{
                                http.Error(w, "Forbidden", http.StatusForbidden)
                                return
                        }</span>

                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                })
        }
}

func Logging(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                log.Printf("[%s] %s %s", r.Method, r.URL.Path, r.RemoteAddr)
                next.ServeHTTP(w, r)
        }</span>)
}

func CORS(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package repository

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
        "github.com/homecooking/backend/internal/db/sqlc"
        "github.com/homecooking/backend/internal/models"
)

type CategoryRepository struct {
        db *sql.DB
        q  *sqlc.Queries
}

func NewCategoryRepository(db *sql.DB, q *sqlc.Queries) *CategoryRepository <span class="cov0" title="0">{
        return &amp;CategoryRepository{
                db: db,
                q:  q,
        }
}</span>

func (r *CategoryRepository) Create(category *models.Category) (*models.Category, error) <span class="cov0" title="0">{
        ctx := context.Background()

        id := category.ID
        if (uuid.UUID{}) == id </span><span class="cov0" title="0">{
                id = uuid.New()
        }</span>

        <span class="cov0" title="0">result, err := r.q.CreateCategory(ctx, sqlc.CreateCategoryParams{
                ID:          id,
                Name:        category.Name,
                Slug:        category.Slug,
                Icon:        sqlNullString(category.Icon),
                Description: sqlNullString(category.Description),
                OrderIndex:  sql.NullInt32{Int32: int32(category.OrderIndex), Valid: category.OrderIndex != 0},
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(result), nil</span>
}

func (r *CategoryRepository) GetByID(id string) (*models.Category, error) <span class="cov0" title="0">{
        ctx := context.Background()
        result, err := r.q.GetCategoryByID(ctx, uuid.MustParse(id))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(result), nil</span>
}

func (r *CategoryRepository) GetBySlug(slug string) (*models.Category, error) <span class="cov0" title="0">{
        ctx := context.Background()
        result, err := r.q.GetCategoryBySlug(ctx, slug)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(result), nil</span>
}

func (r *CategoryRepository) List() ([]*models.Category, error) <span class="cov0" title="0">{
        ctx := context.Background()
        results, err := r.q.ListCategories(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">categories := make([]*models.Category, len(results))
        for i, result := range results </span><span class="cov0" title="0">{
                categories[i] = r.sqlcToModel(result)
        }</span>
        <span class="cov0" title="0">return categories, nil</span>
}

func (r *CategoryRepository) Update(id string, category *models.Category) (*models.Category, error) <span class="cov0" title="0">{
        ctx := context.Background()
        result, err := r.q.UpdateCategory(ctx, sqlc.UpdateCategoryParams{
                ID:          uuid.MustParse(id),
                Name:        sql.NullString{String: category.Name, Valid: true},
                Slug:        sql.NullString{String: category.Slug, Valid: true},
                Icon:        sqlNullString(category.Icon),
                Description: sqlNullString(category.Description),
                OrderIndex:  sql.NullInt32{Int32: int32(category.OrderIndex), Valid: true},
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(result), nil</span>
}

func (r *CategoryRepository) Delete(id string) error <span class="cov0" title="0">{
        ctx := context.Background()
        return r.q.DeleteCategory(ctx, uuid.MustParse(id))
}</span>

func (r *CategoryRepository) sqlcToModel(dbCategory sqlc.Category) *models.Category <span class="cov0" title="0">{
        orderIndex := int(dbCategory.OrderIndex.Int32)
        return &amp;models.Category{
                ID:          dbCategory.ID,
                Name:        dbCategory.Name,
                Slug:        dbCategory.Slug,
                Icon:        nullStringToPtr(dbCategory.Icon),
                Description: nullStringToPtr(dbCategory.Description),
                OrderIndex:  orderIndex,
                CreatedAt:   dbCategory.CreatedAt.Time,
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package repository

import (
        "database/sql"
        "time"

        "github.com/google/uuid"
)

func sqlString(s string) sql.NullString <span class="cov0" title="0">{
        return sql.NullString{String: s, Valid: true}
}</span>

func sqlInt32(i int32) sql.NullInt32 <span class="cov0" title="0">{
        return sql.NullInt32{Int32: i, Valid: true}
}</span>

func sqlNullString(s *string) sql.NullString <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                return sql.NullString{Valid: false}
        }</span>
        <span class="cov8" title="1">return sql.NullString{String: *s, Valid: true}</span>
}

func sqlNullInt32(i *int32) sql.NullInt32 <span class="cov8" title="1">{
        if i == nil </span><span class="cov8" title="1">{
                return sql.NullInt32{Valid: false}
        }</span>
        <span class="cov8" title="1">return sql.NullInt32{Int32: *i, Valid: true}</span>
}

func sqlNullUUID(u *uuid.UUID) uuid.NullUUID <span class="cov8" title="1">{
        if u == nil </span><span class="cov8" title="1">{
                return uuid.NullUUID{Valid: false}
        }</span>
        <span class="cov8" title="1">return uuid.NullUUID{UUID: *u, Valid: true}</span>
}

func sqlNullBool(b bool) sql.NullBool <span class="cov0" title="0">{
        return sql.NullBool{Bool: b, Valid: true}
}</span>

func nullStringToPtr(ns sql.NullString) *string <span class="cov8" title="1">{
        if !ns.Valid </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;ns.String</span>
}

func nullInt32ToPtr(ni sql.NullInt32) *int32 <span class="cov8" title="1">{
        if !ni.Valid </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;ni.Int32</span>
}

func nullUUIDToPtr(nu uuid.NullUUID) *uuid.UUID <span class="cov8" title="1">{
        if !nu.Valid </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;nu.UUID</span>
}

func nullTimeToTimePtr(nt sql.NullTime) *time.Time <span class="cov8" title="1">{
        if !nt.Valid </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;nt.Time</span>
}

func sqlBoolPtr(b bool) sql.NullBool <span class="cov0" title="0">{
        return sql.NullBool{Bool: b, Valid: true}
}</span>

func sqlNullStringPtr(s string) sql.NullString <span class="cov0" title="0">{
        return sql.NullString{String: s, Valid: s != ""}
}</span>

func sqlNullInt32Ptr(i int32) sql.NullInt32 <span class="cov0" title="0">{
        return sql.NullInt32{Int32: i, Valid: true}
}</span>

func sqlNullUUIDPtr(u uuid.UUID) uuid.NullUUID <span class="cov0" title="0">{
        return uuid.NullUUID{UUID: u, Valid: true}
}</span>

func sqlNullBoolPtr(b bool) sql.NullBool <span class="cov0" title="0">{
        return sql.NullBool{Bool: b, Valid: true}
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package repository

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
        "github.com/homecooking/backend/internal/db/sqlc"
        "github.com/homecooking/backend/internal/models"
)

type RecipeGroupRepository struct {
        db *sql.DB
        q  *sqlc.Queries
}

func NewRecipeGroupRepository(db *sql.DB, q *sqlc.Queries) *RecipeGroupRepository <span class="cov0" title="0">{
        return &amp;RecipeGroupRepository{
                db: db,
                q:  q,
        }
}</span>

func (r *RecipeGroupRepository) Create(group *models.RecipeGroup) (*models.RecipeGroup, error) <span class="cov0" title="0">{
        ctx := context.Background()

        id := group.ID
        if (uuid.UUID{}) == id </span><span class="cov0" title="0">{
                id = uuid.New()
        }</span>

        <span class="cov0" title="0">result, err := r.q.CreateRecipeGroup(ctx, sqlc.CreateRecipeGroupParams{
                ID:          id,
                Name:        group.Name,
                Slug:        group.Slug,
                Description: sqlNullString(group.Description),
                Icon:        sqlNullString(group.Icon),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return sqlcToModelRecipeGroup(result), nil</span>
}

func (r *RecipeGroupRepository) GetByID(id string) (*models.RecipeGroup, error) <span class="cov0" title="0">{
        ctx := context.Background()
        parsedID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">result, err := r.q.GetRecipeGroupByID(ctx, parsedID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return sqlcToModelRecipeGroup(result), nil</span>
}

func (r *RecipeGroupRepository) GetBySlug(slug string) (*models.RecipeGroup, error) <span class="cov0" title="0">{
        ctx := context.Background()
        result, err := r.q.GetRecipeGroupBySlug(ctx, slug)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return sqlcToModelRecipeGroup(result), nil</span>
}

func (r *RecipeGroupRepository) List() ([]*models.RecipeGroup, error) <span class="cov0" title="0">{
        ctx := context.Background()
        results, err := r.q.ListRecipeGroups(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">groups := make([]*models.RecipeGroup, len(results))
        for i, row := range results </span><span class="cov0" title="0">{
                groups[i] = sqlcToModelRecipeGroup(row)
        }</span>
        <span class="cov0" title="0">return groups, nil</span>
}

func (r *RecipeGroupRepository) Update(id string, group *models.RecipeGroup) (*models.RecipeGroup, error) <span class="cov0" title="0">{
        ctx := context.Background()
        parsedID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result, err := r.q.UpdateRecipeGroup(ctx, sqlc.UpdateRecipeGroupParams{
                ID:          parsedID,
                Name:        sqlNullStringPtr(group.Name),
                Slug:        sqlNullStringPtr(group.Slug),
                Description: sqlNullString(group.Description),
                Icon:        sqlNullString(group.Icon),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return sqlcToModelRecipeGroup(result), nil</span>
}

func (r *RecipeGroupRepository) Delete(id string) error <span class="cov0" title="0">{
        ctx := context.Background()
        parsedID, err := uuid.Parse(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return r.q.DeleteRecipeGroup(ctx, parsedID)</span>
}

func (r *RecipeGroupRepository) AddRecipeToGroup(groupID, recipeID string) error <span class="cov0" title="0">{
        ctx := context.Background()
        parsedGroupID, err := uuid.Parse(groupID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">parsedRecipeID, err := uuid.Parse(recipeID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">order := int32(0)
        orderNull := sqlNullInt32Ptr(order)
        return r.q.AddRecipeToGroup(ctx, sqlc.AddRecipeToGroupParams{
                GroupID:    parsedGroupID,
                RecipeID:   parsedRecipeID,
                OrderIndex: orderNull,
        })</span>
}

func (r *RecipeGroupRepository) RemoveRecipeFromGroup(groupID, recipeID string) error <span class="cov0" title="0">{
        ctx := context.Background()
        parsedGroupID, err := uuid.Parse(groupID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">parsedRecipeID, err := uuid.Parse(recipeID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return r.q.RemoveRecipeFromGroup(ctx, sqlc.RemoveRecipeFromGroupParams{
                GroupID:  parsedGroupID,
                RecipeID: parsedRecipeID,
        })</span>
}

func (r *RecipeGroupRepository) GetRecipesInGroup(groupID string) ([]*models.Recipe, error) <span class="cov0" title="0">{
        ctx := context.Background()
        parsedID, err := uuid.Parse(groupID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">results, err := r.q.GetRecipesInGroup(ctx, parsedID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">recipes := make([]*models.Recipe, len(results))
        for i, row := range results </span><span class="cov0" title="0">{
                recipes[i] = &amp;models.Recipe{
                        ID:                row.ID,
                        Title:             row.Title,
                        Slug:              row.Slug,
                        Description:       nullStringToPtr(row.Description),
                        FeaturedImagePath: nullStringToPtr(row.FeaturedImagePath),
                        MarkdownContent:   row.MarkdownContent,
                        IsPublished:       row.IsPublished.Bool,
                        CategoryID:        nullUUIDToPtr(row.CategoryID),
                        AuthorID:          nullUUIDToPtr(row.AuthorID),
                        CreatedAt:         row.CreatedAt.Time,
                        UpdatedAt:         row.UpdatedAt.Time,
                        PublishedAt:       nullTimeToTimePtr(row.PublishedAt),
                }
        }</span>
        <span class="cov0" title="0">return recipes, nil</span>
}

func sqlcToModelRecipeGroup(row sqlc.RecipeGroup) *models.RecipeGroup <span class="cov0" title="0">{
        id := row.ID
        return &amp;models.RecipeGroup{
                ID:          id,
                Name:        row.Name,
                Slug:        row.Slug,
                Description: nullStringToPtr(row.Description),
                Icon:        nullStringToPtr(row.Icon),
                CreatedAt:   row.CreatedAt.Time,
        }
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package repository

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
        "github.com/homecooking/backend/internal/db/sqlc"
        "github.com/homecooking/backend/internal/models"
)

type RecipeRepository struct {
        db *sql.DB
        q  *sqlc.Queries
}

func NewRecipeRepository(db *sql.DB, q *sqlc.Queries) *RecipeRepository <span class="cov0" title="0">{
        return &amp;RecipeRepository{
                db: db,
                q:  q,
        }
}</span>

func (r *RecipeRepository) Create(recipe *models.Recipe) (*models.Recipe, error) <span class="cov0" title="0">{
        ctx := context.Background()

        id := recipe.ID
        if (uuid.UUID{}) == id </span><span class="cov0" title="0">{
                id = uuid.New()
        }</span>

        <span class="cov0" title="0">result, err := r.q.CreateRecipe(ctx, sqlc.CreateRecipeParams{
                ID:                id,
                Title:             recipe.Title,
                Slug:              recipe.Slug,
                MarkdownContent:   recipe.MarkdownContent,
                AuthorID:          sqlNullUUID(recipe.AuthorID),
                CategoryID:        sqlNullUUID(recipe.CategoryID),
                Description:       sqlNullString(recipe.Description),
                PrepTimeMinutes:   sqlNullInt32(recipe.PrepTimeMinutes),
                CookTimeMinutes:   sqlNullInt32(recipe.CookTimeMinutes),
                Servings:          sqlNullInt32(recipe.Servings),
                Difficulty:        sqlNullString(recipe.Difficulty),
                FeaturedImagePath: sqlNullString(recipe.FeaturedImagePath),
                IsPublished:       sql.NullBool{Bool: recipe.IsPublished, Valid: true},
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(result), nil</span>
}

func (r *RecipeRepository) GetByID(id string) (*models.Recipe, error) <span class="cov0" title="0">{
        ctx := context.Background()
        result, err := r.q.GetRecipeByID(ctx, uuid.MustParse(id))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(result), nil</span>
}

func (r *RecipeRepository) GetBySlug(slug string) (*models.Recipe, error) <span class="cov0" title="0">{
        ctx := context.Background()
        result, err := r.q.GetRecipeBySlug(ctx, slug)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(result), nil</span>
}

func (r *RecipeRepository) List(limit, offset int) ([]*models.Recipe, error) <span class="cov0" title="0">{
        ctx := context.Background()
        results, err := r.q.ListRecipes(ctx, sqlc.ListRecipesParams{
                Limit:  int32(limit),
                Offset: int32(offset),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">recipes := make([]*models.Recipe, len(results))
        for i, result := range results </span><span class="cov0" title="0">{
                recipes[i] = r.sqlcToModel(result)
        }</span>
        <span class="cov0" title="0">return recipes, nil</span>
}

func (r *RecipeRepository) Search(query string, limit, offset int) ([]*models.Recipe, error) <span class="cov0" title="0">{
        ctx := context.Background()
        results, err := r.q.SearchRecipes(ctx, sqlc.SearchRecipesParams{
                Column1: sql.NullString{String: query, Valid: true},
                Limit:   int32(limit),
                Offset:  int32(offset),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">recipes := make([]*models.Recipe, len(results))
        for i, result := range results </span><span class="cov0" title="0">{
                recipes[i] = r.sqlcToModel(result)
        }</span>
        <span class="cov0" title="0">return recipes, nil</span>
}

func (r *RecipeRepository) Update(id string, recipe *models.Recipe) (*models.Recipe, error) <span class="cov0" title="0">{
        ctx := context.Background()
        result, err := r.q.UpdateRecipe(ctx, sqlc.UpdateRecipeParams{
                ID:                uuid.MustParse(id),
                Title:             sqlNullStringPtr(recipe.Title),
                MarkdownContent:   sqlNullStringPtr(recipe.MarkdownContent),
                CategoryID:        sqlNullUUID(recipe.CategoryID),
                Description:       sqlNullString(recipe.Description),
                PrepTimeMinutes:   sqlNullInt32(recipe.PrepTimeMinutes),
                CookTimeMinutes:   sqlNullInt32(recipe.CookTimeMinutes),
                Servings:          sqlNullInt32(recipe.Servings),
                Difficulty:        sqlNullString(recipe.Difficulty),
                FeaturedImagePath: sqlNullString(recipe.FeaturedImagePath),
                IsPublished:       sqlNullBoolPtr(recipe.IsPublished),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(result), nil</span>
}

func (r *RecipeRepository) UpdatePublishedStatus(id string, isPublished bool) (*models.Recipe, error) <span class="cov0" title="0">{
        ctx := context.Background()
        result, err := r.q.UpdateRecipePublishedStatus(ctx, sqlc.UpdateRecipePublishedStatusParams{
                ID:          uuid.MustParse(id),
                IsPublished: sql.NullBool{Bool: isPublished, Valid: true},
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(result), nil</span>
}

func (r *RecipeRepository) Delete(id string) error <span class="cov0" title="0">{
        ctx := context.Background()
        return r.q.DeleteRecipe(ctx, uuid.MustParse(id))
}</span>

func (r *RecipeRepository) UpdateFeaturedImage(id string, imagePath *string) error <span class="cov0" title="0">{
        ctx := context.Background()
        _, err := r.q.UpdateRecipeFeaturedImage(ctx, sqlc.UpdateRecipeFeaturedImageParams{
                ID:                uuid.MustParse(id),
                FeaturedImagePath: sqlNullString(imagePath),
        })
        return err
}</span>

func (r *RecipeRepository) sqlcToModel(dbRecipe sqlc.Recipe) *models.Recipe <span class="cov0" title="0">{
        return &amp;models.Recipe{
                ID:                dbRecipe.ID,
                Title:             dbRecipe.Title,
                Slug:              dbRecipe.Slug,
                MarkdownContent:   dbRecipe.MarkdownContent,
                AuthorID:          nullUUIDToPtr(dbRecipe.AuthorID),
                CategoryID:        nullUUIDToPtr(dbRecipe.CategoryID),
                Description:       nullStringToPtr(dbRecipe.Description),
                PrepTimeMinutes:   nullInt32ToPtr(dbRecipe.PrepTimeMinutes),
                CookTimeMinutes:   nullInt32ToPtr(dbRecipe.CookTimeMinutes),
                Servings:          nullInt32ToPtr(dbRecipe.Servings),
                Difficulty:        nullStringToPtr(dbRecipe.Difficulty),
                FeaturedImagePath: nullStringToPtr(dbRecipe.FeaturedImagePath),
                IsPublished:       dbRecipe.IsPublished.Bool,
                CreatedAt:         dbRecipe.CreatedAt.Time,
                UpdatedAt:         dbRecipe.UpdatedAt.Time,
                PublishedAt:       nullTimeToTimePtr(dbRecipe.PublishedAt),
        }
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package repository

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
        "github.com/homecooking/backend/internal/db/sqlc"
        "github.com/homecooking/backend/internal/models"
)

type TagRepository struct {
        db *sql.DB
        q  *sqlc.Queries
}

func NewTagRepository(db *sql.DB, q *sqlc.Queries) *TagRepository <span class="cov0" title="0">{
        return &amp;TagRepository{
                db: db,
                q:  q,
        }
}</span>

func (r *TagRepository) Create(tag *models.Tag) (*models.Tag, error) <span class="cov0" title="0">{
        ctx := context.Background()

        id := tag.ID
        if (uuid.UUID{}) == id </span><span class="cov0" title="0">{
                id = uuid.New()
        }</span>

        <span class="cov0" title="0">result, err := r.q.CreateTag(ctx, sqlc.CreateTagParams{
                ID:    id,
                Name:  tag.Name,
                Slug:  tag.Slug,
                Color: sql.NullString{String: tag.Color, Valid: true},
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(result), nil</span>
}

func (r *TagRepository) GetByID(id string) (*models.Tag, error) <span class="cov0" title="0">{
        ctx := context.Background()
        result, err := r.q.GetTagByID(ctx, uuid.MustParse(id))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(result), nil</span>
}

func (r *TagRepository) GetBySlug(slug string) (*models.Tag, error) <span class="cov0" title="0">{
        ctx := context.Background()
        result, err := r.q.GetTagBySlug(ctx, slug)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(result), nil</span>
}

func (r *TagRepository) List() ([]*models.Tag, error) <span class="cov0" title="0">{
        ctx := context.Background()
        results, err := r.q.ListTags(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tags := make([]*models.Tag, len(results))
        for i, result := range results </span><span class="cov0" title="0">{
                tags[i] = r.sqlcToModel(result)
        }</span>
        <span class="cov0" title="0">return tags, nil</span>
}

func (r *TagRepository) Update(id string, tag *models.Tag) (*models.Tag, error) <span class="cov0" title="0">{
        ctx := context.Background()
        result, err := r.q.UpdateTag(ctx, sqlc.UpdateTagParams{
                ID:    uuid.MustParse(id),
                Name:  sql.NullString{String: tag.Name, Valid: true},
                Slug:  sql.NullString{String: tag.Slug, Valid: true},
                Color: sql.NullString{String: tag.Color, Valid: true},
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(result), nil</span>
}

func (r *TagRepository) Delete(id string) error <span class="cov0" title="0">{
        ctx := context.Background()
        return r.q.DeleteTag(ctx, uuid.MustParse(id))
}</span>

func (r *TagRepository) AddToRecipe(recipeID string, tagID string) error <span class="cov0" title="0">{
        ctx := context.Background()
        return r.q.AddTagToRecipe(ctx, sqlc.AddTagToRecipeParams{
                RecipeID: uuid.MustParse(recipeID),
                TagID:    uuid.MustParse(tagID),
        })
}</span>

func (r *TagRepository) RemoveFromRecipe(recipeID string, tagID string) error <span class="cov0" title="0">{
        ctx := context.Background()
        return r.q.RemoveTagFromRecipe(ctx, sqlc.RemoveTagFromRecipeParams{
                RecipeID: uuid.MustParse(recipeID),
                TagID:    uuid.MustParse(tagID),
        })
}</span>

func (r *TagRepository) GetRecipeTags(recipeID string) ([]*models.Tag, error) <span class="cov0" title="0">{
        ctx := context.Background()
        results, err := r.q.GetRecipeTags(ctx, uuid.MustParse(recipeID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">tags := make([]*models.Tag, len(results))
        for i, result := range results </span><span class="cov0" title="0">{
                tags[i] = r.sqlcToModel(result)
        }</span>
        <span class="cov0" title="0">return tags, nil</span>
}

func (r *TagRepository) sqlcToModel(dbTag sqlc.Tag) *models.Tag <span class="cov0" title="0">{
        color := dbTag.Color.String
        if !dbTag.Color.Valid </span><span class="cov0" title="0">{
                color = "#6366f1"
        }</span>
        <span class="cov0" title="0">return &amp;models.Tag{
                ID:        dbTag.ID,
                Name:      dbTag.Name,
                Slug:      dbTag.Slug,
                Color:     color,
                CreatedAt: dbTag.CreatedAt.Time,
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package repository

import (
        "context"
        "database/sql"

        "github.com/google/uuid"
        "github.com/homecooking/backend/internal/db/sqlc"
        "github.com/homecooking/backend/internal/models"
)

type UserRepository struct {
        db *sql.DB
        q  *sqlc.Queries
}

func NewUserRepository(db *sql.DB, q *sqlc.Queries) *UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{
                db: db,
                q:  q,
        }
}</span>

func (r *UserRepository) Create(user *models.User) (*models.User, error) <span class="cov0" title="0">{
        ctx := context.Background()
        result, err := r.q.CreateUser(ctx, sqlc.CreateUserParams{
                Email:        user.Email,
                PasswordHash: user.PasswordHash,
                Role:         user.Role,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dbUser, err := r.q.GetUserByID(ctx, result.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return r.sqlcToModel(dbUser), nil</span>
}

func (r *UserRepository) GetByID(id string) (*models.User, error) <span class="cov0" title="0">{
        ctx := context.Background()
        dbUser, err := r.q.GetUserByID(ctx, uuid.MustParse(id))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(dbUser), nil</span>
}

func (r *UserRepository) GetByEmail(email string) (*models.User, error) <span class="cov0" title="0">{
        ctx := context.Background()
        dbUser, err := r.q.GetUserByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(dbUser), nil</span>
}

func (r *UserRepository) List(limit, offset int) ([]*models.User, error) <span class="cov0" title="0">{
        ctx := context.Background()
        dbUsers, err := r.q.ListUsers(ctx, sqlc.ListUsersParams{
                Limit:  int32(limit),
                Offset: int32(offset),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">users := make([]*models.User, len(dbUsers))
        for i, dbUser := range dbUsers </span><span class="cov0" title="0">{
                users[i] = r.sqlcToModel(dbUser)
        }</span>
        <span class="cov0" title="0">return users, nil</span>
}

func (r *UserRepository) Update(id string, user *models.User) (*models.User, error) <span class="cov0" title="0">{
        ctx := context.Background()
        result, err := r.q.UpdateUser(ctx, sqlc.UpdateUserParams{
                ID:    uuid.MustParse(id),
                Email: sqlString(user.Email),
                Role:  sqlString(user.Role),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.sqlcToModel(result), nil</span>
}

func (r *UserRepository) Delete(id string) error <span class="cov0" title="0">{
        ctx := context.Background()
        return r.q.DeleteUser(ctx, uuid.MustParse(id))
}</span>

func (r *UserRepository) sqlcToModel(dbUser sqlc.User) *models.User <span class="cov0" title="0">{
        return &amp;models.User{
                ID:           dbUser.ID,
                Email:        dbUser.Email,
                PasswordHash: dbUser.PasswordHash,
                Role:         dbUser.Role,
                CreatedAt:    dbUser.CreatedAt.Time,
                UpdatedAt:    dbUser.UpdatedAt.Time,
        }
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package services

import (
        "errors"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/homecooking/backend/internal/config"
        "github.com/homecooking/backend/internal/models"
        "github.com/homecooking/backend/internal/repository"
        "golang.org/x/crypto/bcrypt"
)

type AuthService struct {
        cfg      *config.Config
        userRepo *repository.UserRepository
}

type Claims struct {
        UserID string `json:"user_id"`
        Email  string `json:"email"`
        Role   string `json:"role"`
        jwt.RegisteredClaims
}

func NewAuthService(cfg *config.Config, userRepo *repository.UserRepository) *AuthService <span class="cov8" title="1">{
        return &amp;AuthService{
                cfg:      cfg,
                userRepo: userRepo,
        }
}</span>

func (s *AuthService) Register(req *models.RegisterRequest) (*models.User, error) <span class="cov0" title="0">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">user, err := s.userRepo.Create(&amp;models.User{
                Email:        req.Email,
                PasswordHash: string(hashedPassword),
                Role:         "user",
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (s *AuthService) Login(req *models.LoginRequest) (*models.TokenResponse, error) <span class="cov8" title="1">{
        user, err := s.userRepo.GetByEmail(req.Email)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("invalid credentials")
        }</span>

        <span class="cov8" title="1">if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password)); err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("invalid credentials")
        }</span>

        <span class="cov8" title="1">accessToken, err := s.generateAccessToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">refreshToken, err := s.generateRefreshToken(user)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;models.TokenResponse{
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
                ExpiresIn:    s.cfg.Auth.TokenExpiryHours * 3600,
        }, nil</span>
}

func (s *AuthService) ValidateToken(tokenString string) (*models.User, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return []byte(s.cfg.Auth.JWTSecret), nil
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov8" title="1">{
                user, err := s.userRepo.GetByID(claims.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return user, nil</span>
        }

        <span class="cov0" title="0">return nil, errors.New("invalid token")</span>
}

func (s *AuthService) RefreshToken(refreshToken string) (*models.TokenResponse, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(refreshToken, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return []byte(s.cfg.Auth.RefreshSecret), nil
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov8" title="1">{
                user, err := s.userRepo.GetByID(claims.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">accessToken, err := s.generateAccessToken(user)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">newRefreshToken, err := s.generateRefreshToken(user)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return &amp;models.TokenResponse{
                        AccessToken:  accessToken,
                        RefreshToken: newRefreshToken,
                        ExpiresIn:    s.cfg.Auth.TokenExpiryHours * 3600,
                }, nil</span>
        }

        <span class="cov0" title="0">return nil, errors.New("invalid token")</span>
}

func (s *AuthService) generateAccessToken(user *models.User) (string, error) <span class="cov8" title="1">{
        claims := &amp;Claims{
                UserID: user.ID.String(),
                Email:  user.Email,
                Role:   user.Role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Duration(s.cfg.Auth.TokenExpiryHours) * time.Hour)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(s.cfg.Auth.JWTSecret))
}</span>

func (s *AuthService) generateRefreshToken(user *models.User) (string, error) <span class="cov8" title="1">{
        claims := &amp;Claims{
                UserID: user.ID.String(),
                Email:  user.Email,
                Role:   user.Role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * 7 * time.Hour)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(s.cfg.Auth.RefreshSecret))
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package services

import (
        "errors"
        "strings"

        "github.com/homecooking/backend/internal/models"
        "github.com/homecooking/backend/internal/repository"
)

type CategoryService struct {
        categoryRepo *repository.CategoryRepository
}

func NewCategoryService(categoryRepo *repository.CategoryRepository) *CategoryService <span class="cov8" title="1">{
        return &amp;CategoryService{
                categoryRepo: categoryRepo,
        }
}</span>

func (s *CategoryService) CreateCategory(category *models.Category) (*models.Category, error) <span class="cov8" title="1">{
        if category.Name == "" </span><span class="cov8" title="1">{
                return nil, errors.New("name is required")
        }</span>
        <span class="cov8" title="1">if category.Slug == "" </span><span class="cov8" title="1">{
                category.Slug = generateCategorySlug(category.Name)
        }</span>

        <span class="cov8" title="1">return s.categoryRepo.Create(category)</span>
}

func (s *CategoryService) GetCategory(id string) (*models.Category, error) <span class="cov8" title="1">{
        return s.categoryRepo.GetByID(id)
}</span>

func (s *CategoryService) GetBySlug(slug string) (*models.Category, error) <span class="cov8" title="1">{
        return s.categoryRepo.GetBySlug(slug)
}</span>

func (s *CategoryService) ListCategories() ([]*models.Category, error) <span class="cov8" title="1">{
        return s.categoryRepo.List()
}</span>

func (s *CategoryService) UpdateCategory(id string, category *models.Category) (*models.Category, error) <span class="cov8" title="1">{
        if category.Name == "" </span><span class="cov8" title="1">{
                return nil, errors.New("name is required")
        }</span>
        <span class="cov8" title="1">if category.Slug == "" &amp;&amp; category.Name != "" </span><span class="cov8" title="1">{
                category.Slug = generateCategorySlug(category.Name)
        }</span>

        <span class="cov8" title="1">return s.categoryRepo.Update(id, category)</span>
}

func (s *CategoryService) DeleteCategory(id string) error <span class="cov8" title="1">{
        return s.categoryRepo.Delete(id)
}</span>

func generateCategorySlug(title string) string <span class="cov8" title="1">{
        slug := strings.ToLower(title)
        slug = strings.ReplaceAll(slug, " ", "-")
        slug = strings.ReplaceAll(slug, "'", "")
        slug = strings.ReplaceAll(slug, "\"", "")
        return slug
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package services

import (
        "fmt"
        "strings"

        "github.com/google/uuid"
        "github.com/homecooking/backend/internal/models"
        "github.com/homecooking/backend/internal/repository"
)

type RecipeGroupService struct {
        repo *repository.RecipeGroupRepository
}

func NewRecipeGroupService(repo *repository.RecipeGroupRepository) *RecipeGroupService <span class="cov8" title="1">{
        return &amp;RecipeGroupService{
                repo: repo,
        }
}</span>

func (s *RecipeGroupService) Create(group *models.RecipeGroup) (*models.RecipeGroup, error) <span class="cov8" title="1">{
        if group.Slug == "" </span><span class="cov8" title="1">{
                group.Slug = s.GenerateSlug(group.Name)
        }</span>
        <span class="cov8" title="1">return s.repo.Create(group)</span>
}

func (s *RecipeGroupService) GetByID(id string) (*models.RecipeGroup, error) <span class="cov8" title="1">{
        return s.repo.GetByID(id)
}</span>

func (s *RecipeGroupService) GetBySlug(slug string) (*models.RecipeGroup, error) <span class="cov8" title="1">{
        return s.repo.GetBySlug(slug)
}</span>

func (s *RecipeGroupService) List() ([]*models.RecipeGroup, error) <span class="cov8" title="1">{
        return s.repo.List()
}</span>

func (s *RecipeGroupService) Update(id string, group *models.RecipeGroup) (*models.RecipeGroup, error) <span class="cov0" title="0">{
        if id != "" </span><span class="cov0" title="0">{
                _, err := s.GetByID(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if group.Slug == "" </span><span class="cov0" title="0">{
                group.Slug = s.GenerateSlug(group.Name)
        }</span>
        <span class="cov0" title="0">return s.repo.Update(id, group)</span>
}

func (s *RecipeGroupService) Delete(id string) error <span class="cov8" title="1">{
        return s.repo.Delete(id)
}</span>

func (s *RecipeGroupService) AddRecipeToGroup(groupID, recipeID string) error <span class="cov8" title="1">{
        return s.repo.AddRecipeToGroup(groupID, recipeID)
}</span>

func (s *RecipeGroupService) RemoveRecipeFromGroup(groupID, recipeID string) error <span class="cov8" title="1">{
        return s.repo.RemoveRecipeFromGroup(groupID, recipeID)
}</span>

func (s *RecipeGroupService) GetRecipesInGroup(groupID string) ([]*models.Recipe, error) <span class="cov8" title="1">{
        return s.repo.GetRecipesInGroup(groupID)
}</span>

func (s *RecipeGroupService) GenerateSlug(name string) string <span class="cov8" title="1">{
        slug := strings.ToLower(strings.ReplaceAll(name, " ", "-"))
        slug = strings.Map(func(r rune) rune </span><span class="cov8" title="1">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == '-' </span><span class="cov8" title="1">{
                        return r
                }</span>
                <span class="cov8" title="1">return '-'</span>
        }, slug)

        <span class="cov8" title="1">slug = strings.Trim(slug, "-")
        if slug == "" </span><span class="cov0" title="0">{
                slug = fmt.Sprintf("group-%s", uuid.New().String()[:8])
        }</span>
        <span class="cov8" title="1">return slug</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package services

import (
        "errors"
        "strings"

        "github.com/google/uuid"
        "github.com/homecooking/backend/internal/models"
        "github.com/homecooking/backend/internal/repository"
)

type RecipeService struct {
        recipeRepo *repository.RecipeRepository
}

func NewRecipeService(recipeRepo *repository.RecipeRepository) *RecipeService <span class="cov8" title="1">{
        return &amp;RecipeService{
                recipeRepo: recipeRepo,
        }
}</span>

func (s *RecipeService) CreateRecipe(recipe *models.CreateRecipeRequest, authorID string) (*models.Recipe, error) <span class="cov8" title="1">{
        if recipe.Title == "" </span><span class="cov8" title="1">{
                return nil, errors.New("title is required")
        }</span>
        <span class="cov8" title="1">if recipe.MarkdownContent == "" </span><span class="cov8" title="1">{
                return nil, errors.New("markdown content is required")
        }</span>

        <span class="cov8" title="1">slug := generateSlug(recipe.Title)
        authorUUID := uuid.MustParse(authorID)

        recipeModel := &amp;models.Recipe{
                Title:             recipe.Title,
                Slug:              slug,
                MarkdownContent:   recipe.MarkdownContent,
                AuthorID:          &amp;authorUUID,
                CategoryID:        parseUUID(recipe.CategoryID),
                Description:       recipe.Description,
                PrepTimeMinutes:   recipe.PrepTimeMinutes,
                CookTimeMinutes:   recipe.CookTimeMinutes,
                Servings:          recipe.Servings,
                Difficulty:        recipe.Difficulty,
                FeaturedImagePath: recipe.FeaturedImagePath,
                IsPublished:       recipe.IsPublished,
        }

        return s.recipeRepo.Create(recipeModel)</span>
}

func (s *RecipeService) GetRecipe(id string) (*models.Recipe, error) <span class="cov8" title="1">{
        return s.recipeRepo.GetByID(id)
}</span>

func (s *RecipeService) GetRecipeBySlug(slug string) (*models.Recipe, error) <span class="cov8" title="1">{
        return s.recipeRepo.GetBySlug(slug)
}</span>

func (s *RecipeService) ListRecipes(limit, offset int) ([]*models.Recipe, error) <span class="cov8" title="1">{
        return s.recipeRepo.List(limit, offset)
}</span>

func (s *RecipeService) SearchRecipes(query string, limit, offset int) ([]*models.Recipe, error) <span class="cov0" title="0">{
        return s.recipeRepo.Search(query, limit, offset)
}</span>

func (s *RecipeService) UpdateRecipe(id string, req *models.UpdateRecipeRequest, authorID string) (*models.Recipe, error) <span class="cov8" title="1">{
        existing, err := s.recipeRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if existing.AuthorID.String() != authorID </span><span class="cov8" title="1">{
                return nil, errors.New("unauthorized: you can only edit your own recipes")
        }</span>

        <span class="cov0" title="0">recipeModel := &amp;models.Recipe{
                Title:             toString(req.Title, existing.Title),
                MarkdownContent:   toString(req.MarkdownContent, existing.MarkdownContent),
                CategoryID:        parseUUID(req.CategoryID),
                Description:       req.Description,
                PrepTimeMinutes:   req.PrepTimeMinutes,
                CookTimeMinutes:   req.CookTimeMinutes,
                Servings:          req.Servings,
                Difficulty:        req.Difficulty,
                FeaturedImagePath: req.FeaturedImagePath,
                IsPublished:       toBool(req.IsPublished, existing.IsPublished),
        }

        if req.Title != nil </span><span class="cov0" title="0">{
                recipeModel.Slug = generateSlug(*req.Title)
        }</span>

        <span class="cov0" title="0">return s.recipeRepo.Update(id, recipeModel)</span>
}

func (s *RecipeService) DeleteRecipe(id string, authorID string) error <span class="cov8" title="1">{
        existing, err := s.recipeRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if existing.AuthorID.String() != authorID </span><span class="cov8" title="1">{
                return errors.New("unauthorized: you can only delete your own recipes")
        }</span>

        <span class="cov8" title="1">return s.recipeRepo.Delete(id)</span>
}

func (s *RecipeService) PublishRecipe(id string, authorID string, published bool) (*models.Recipe, error) <span class="cov8" title="1">{
        existing, err := s.recipeRepo.GetByID(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if existing.AuthorID.String() != authorID </span><span class="cov8" title="1">{
                return nil, errors.New("unauthorized: you can only publish your own recipes")
        }</span>

        <span class="cov0" title="0">return s.recipeRepo.UpdatePublishedStatus(id, published)</span>
}

func generateSlug(title string) string <span class="cov8" title="1">{
        slug := strings.ToLower(title)
        slug = strings.ReplaceAll(slug, " ", "-")
        slug = strings.ReplaceAll(slug, "'", "")
        slug = strings.ReplaceAll(slug, "\"", "")
        return slug
}</span>

func parseUUID(s *string) *uuid.UUID <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">parsed, err := uuid.Parse(*s)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;parsed</span>
}

func toString(s *string, defaultVal string) string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">return *s</span>
}

func toBool(b *bool, defaultVal bool) bool <span class="cov0" title="0">{
        if b == nil </span><span class="cov0" title="0">{
                return defaultVal
        }</span>
        <span class="cov0" title="0">return *b</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package services

import (
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "image"
        "image/jpeg"
        "image/png"
        "mime/multipart"
        "os"
        "path/filepath"
        "strings"
)

type StorageService struct {
        localPath string
        maxSize   int64
}

func NewStorageService(localPath string, maxSize int64) *StorageService <span class="cov8" title="1">{
        return &amp;StorageService{
                localPath: localPath,
                maxSize:   maxSize,
        }
}</span>

func (s *StorageService) SaveImage(file *multipart.FileHeader, prefix string) (string, error) <span class="cov8" title="1">{
        if file.Size &gt; s.maxSize </span><span class="cov8" title="1">{
                return "", fmt.Errorf("file size exceeds maximum allowed size")
        }</span>

        <span class="cov8" title="1">src, err := file.Open()
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to open uploaded file: %w", err)
        }</span>
        <span class="cov0" title="0">defer src.Close()

        ext := strings.ToLower(filepath.Ext(file.Filename))
        if !s.isValidImageExtension(ext) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid file type: %s", ext)
        }</span>

        <span class="cov0" title="0">filename := s.generateFilename(prefix, ext)
        dstPath := filepath.Join(s.localPath, filename)

        img, _, err := image.Decode(src)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode image: %w", err)
        }</span>

        <span class="cov0" title="0">resized, err := s.resizeImage(img, 1200, 800)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to resize image: %w", err)
        }</span>

        <span class="cov0" title="0">dst, err := os.Create(dstPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create destination file: %w", err)
        }</span>
        <span class="cov0" title="0">defer dst.Close()

        if ext == ".png" </span><span class="cov0" title="0">{
                err = png.Encode(dst, resized)
        }</span> else<span class="cov0" title="0"> {
                opts := &amp;jpeg.Options{Quality: 85}
                err = jpeg.Encode(dst, resized, opts)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encode image: %w", err)
        }</span>

        <span class="cov0" title="0">return filename, nil</span>
}

func (s *StorageService) resizeImage(img image.Image, maxWidth, maxHeight int) (image.Image, error) <span class="cov8" title="1">{
        bounds := img.Bounds()

        if bounds.Dx() &lt;= maxWidth &amp;&amp; bounds.Dy() &lt;= maxHeight </span><span class="cov8" title="1">{
                return img, nil
        }</span>

        <span class="cov8" title="1">ratio := float64(maxWidth) / float64(bounds.Dx())
        if float64(bounds.Dy())*ratio &gt; float64(maxHeight) </span><span class="cov8" title="1">{
                ratio = float64(maxHeight) / float64(bounds.Dy())
        }</span>

        <span class="cov8" title="1">newWidth := int(float64(bounds.Dx()) * ratio)
        newHeight := int(float64(bounds.Dy()) * ratio)

        thumbnail := image.NewRGBA(image.Rect(0, 0, newWidth, newHeight))
        for y := 0; y &lt; newHeight; y++ </span><span class="cov8" title="1">{
                for x := 0; x &lt; newWidth; x++ </span><span class="cov8" title="1">{
                        srcX := int(float64(x) / ratio)
                        srcY := int(float64(y) / ratio)
                        if srcX &lt; bounds.Dx() &amp;&amp; srcY &lt; bounds.Dy() </span><span class="cov8" title="1">{
                                thumbnail.Set(x, y, img.At(srcX, srcY))
                        }</span>
                }
        }

        <span class="cov8" title="1">return thumbnail, nil</span>
}

func (s *StorageService) DeleteImage(filename string) error <span class="cov8" title="1">{
        path := filepath.Join(s.localPath, filename)
        if err := os.Remove(path); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete file: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (s *StorageService) isValidImageExtension(ext string) bool <span class="cov8" title="1">{
        validExts := map[string]bool{
                ".jpg":  true,
                ".jpeg": true,
                ".png":  true,
                ".gif":  true,
                ".webp": true,
        }
        return validExts[ext]
}</span>

func (s *StorageService) generateFilename(prefix string, ext string) string <span class="cov8" title="1">{
        randBytes := make([]byte, 8)
        rand.Read(randBytes)
        randomStr := hex.EncodeToString(randBytes)
        return fmt.Sprintf("%s_%s%s", prefix, randomStr, ext)
}</span>

func (s *StorageService) EnsureDirectory() error <span class="cov8" title="1">{
        if err := os.MkdirAll(s.localPath, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create upload directory: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package services

import (
        "errors"
        "strings"

        "github.com/homecooking/backend/internal/models"
        "github.com/homecooking/backend/internal/repository"
)

type TagService struct {
        tagRepo *repository.TagRepository
}

func NewTagService(tagRepo *repository.TagRepository) *TagService <span class="cov8" title="1">{
        return &amp;TagService{
                tagRepo: tagRepo,
        }
}</span>

func (s *TagService) CreateTag(tag *models.Tag) (*models.Tag, error) <span class="cov8" title="1">{
        if tag.Name == "" </span><span class="cov8" title="1">{
                return nil, errors.New("name is required")
        }</span>
        <span class="cov8" title="1">if tag.Slug == "" </span><span class="cov8" title="1">{
                tag.Slug = generateTagSlug(tag.Name)
        }</span>
        <span class="cov8" title="1">if tag.Color == "" </span><span class="cov8" title="1">{
                tag.Color = "#6366f1"
        }</span>

        <span class="cov8" title="1">return s.tagRepo.Create(tag)</span>
}

func (s *TagService) GetTag(id string) (*models.Tag, error) <span class="cov8" title="1">{
        return s.tagRepo.GetByID(id)
}</span>

func (s *TagService) GetBySlug(slug string) (*models.Tag, error) <span class="cov0" title="0">{
        return s.tagRepo.GetBySlug(slug)
}</span>

func (s *TagService) ListTags() ([]*models.Tag, error) <span class="cov8" title="1">{
        return s.tagRepo.List()
}</span>

func (s *TagService) UpdateTag(id string, tag *models.Tag) (*models.Tag, error) <span class="cov0" title="0">{
        if tag.Name == "" </span><span class="cov0" title="0">{
                return nil, errors.New("name is required")
        }</span>
        <span class="cov0" title="0">if tag.Slug == "" &amp;&amp; tag.Name != "" </span><span class="cov0" title="0">{
                tag.Slug = generateTagSlug(tag.Name)
        }</span>
        <span class="cov0" title="0">if tag.Color == "" </span><span class="cov0" title="0">{
                tag.Color = "#6366f1"
        }</span>

        <span class="cov0" title="0">return s.tagRepo.Update(id, tag)</span>
}

func (s *TagService) DeleteTag(id string) error <span class="cov8" title="1">{
        return s.tagRepo.Delete(id)
}</span>

func (s *TagService) GetRecipeTags(recipeID string) ([]*models.Tag, error) <span class="cov8" title="1">{
        return s.tagRepo.GetRecipeTags(recipeID)
}</span>

func (s *TagService) AddTagToRecipe(recipeID string, tagID string) error <span class="cov8" title="1">{
        return s.tagRepo.AddToRecipe(recipeID, tagID)
}</span>

func (s *TagService) RemoveTagFromRecipe(recipeID string, tagID string) error <span class="cov8" title="1">{
        return s.tagRepo.RemoveFromRecipe(recipeID, tagID)
}</span>

func generateTagSlug(title string) string <span class="cov8" title="1">{
        slug := strings.ToLower(title)
        slug = strings.ReplaceAll(slug, " ", "-")
        slug = strings.ReplaceAll(slug, "'", "")
        slug = strings.ReplaceAll(slug, "\"", "")
        return slug
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package testing

import (
        "time"

        "github.com/google/uuid"
        "github.com/homecooking/backend/internal/models"
)

var (
        // Test Users
        TestUser1 = &amp;models.User{
                ID:        uuid.MustParse("00000000-0000-0000-0000-000000000001"),
                Email:     "test@example.com",
                Role:      "user",
                CreatedAt: time.Now(),
        }

        TestAdminUser = &amp;models.User{
                ID:        uuid.MustParse("00000000-0000-0000-0000-000000000002"),
                Email:     "admin@example.com",
                Role:      "admin",
                CreatedAt: time.Now(),
        }

        TestUser2 = &amp;models.User{
                ID:        uuid.MustParse("00000000-0000-0000-0000-000000000003"),
                Email:     "editor@example.com",
                Role:      "editor",
                CreatedAt: time.Now(),
        }
)

var (
        // Test Categories
        TestCategory1 = &amp;models.Category{
                ID:         uuid.MustParse("00000000-0000-0000-0000-000000000011"),
                Name:       "Breakfast",
                Slug:       "breakfast",
                Icon:       stringPtr(""),
                OrderIndex: 1,
                CreatedAt:  time.Now(),
        }

        TestCategory2 = &amp;models.Category{
                ID:         uuid.MustParse("00000000-0000-0000-0000-000000000012"),
                Name:       "Dinner",
                Slug:       "dinner",
                OrderIndex: 2,
                CreatedAt:  time.Now(),
        }

        TestCategory3 = &amp;models.Category{
                ID:         uuid.MustParse("00000000-0000-0000-0000-000000000013"),
                Name:       "Desserts",
                Slug:       "desserts",
                Icon:       stringPtr(""),
                OrderIndex: 3,
                CreatedAt:  time.Now(),
        }
)

var (
        // Test Tags
        TestTag1 = &amp;models.Tag{
                ID:        uuid.MustParse("00000000-0000-0000-0000-000000000021"),
                Name:      "Vegetarian",
                Slug:      "vegetarian",
                Color:     "#6366f1",
                CreatedAt: time.Now(),
        }

        TestTag2 = &amp;models.Tag{
                ID:        uuid.MustParse("00000000-0000-0000-0000-000000000022"),
                Name:      "Quick",
                Slug:      "quick",
                Color:     "#6366f1",
                CreatedAt: time.Now(),
        }

        TestTag3 = &amp;models.Tag{
                ID:        uuid.MustParse("00000000-0000-0000-0000-000000000023"),
                Name:      "Spicy",
                Slug:      "spicy",
                Color:     "#ef4444",
                CreatedAt: time.Now(),
        }
)

var (
        // Test Recipe Groups
        TestGroup1 = &amp;models.RecipeGroup{
                ID:          uuid.MustParse("00000000-0000-0000-0000-000000000031"),
                Name:        "Comfort Food",
                Slug:        "comfort-food",
                Icon:        stringPtr(""),
                Description: stringPtr("Classic comfort dishes"),
                CreatedAt:   time.Now(),
        }

        TestGroup2 = &amp;models.RecipeGroup{
                ID:          uuid.MustParse("00000000-0000-0000-0000-000000000032"),
                Name:        "Biscuits &amp; Gravy",
                Slug:        "biscuits-gravy",
                Icon:        stringPtr(""),
                Description: stringPtr("Southern breakfast combo"),
                CreatedAt:   time.Now(),
        }
)

var (
        // Test Recipes
        TestRecipe1 = &amp;models.Recipe{
                ID:              uuid.MustParse("00000000-0000-0000-0000-000000000041"),
                Title:           "Fluffy Pancakes",
                Slug:            "fluffy-pancakes",
                MarkdownContent: "## Ingredients\n\n- 2 cups flour\n- 2 eggs\n- 1 cup milk\n\n## Instructions\n\nMix all ingredients and cook on hot griddle.",
                Description:     stringPtr("Fluffy breakfast pancakes"),
                PrepTimeMinutes: int32Ptr(10),
                CookTimeMinutes: int32Ptr(15),
                Servings:        int32Ptr(4),
                Difficulty:      stringPtr("easy"),
                IsPublished:     true,
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
        }

        TestRecipe2 = &amp;models.Recipe{
                ID:              uuid.MustParse("00000000-0000-0000-0000-000000000042"),
                Title:           "Cheese Omelette",
                Slug:            "cheese-omelette",
                MarkdownContent: "## Ingredients\n\n- 3 eggs\n- 1/2 cup shredded cheese\n- Salt and pepper\n\n## Instructions\n\nBeat eggs, cook in pan, add cheese, fold.",
                Description:     stringPtr("Simple cheese omelette"),
                PrepTimeMinutes: int32Ptr(5),
                CookTimeMinutes: int32Ptr(10),
                Servings:        int32Ptr(2),
                Difficulty:      stringPtr("easy"),
                IsPublished:     false,
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
        }

        TestRecipe3 = &amp;models.Recipe{
                ID:              uuid.MustParse("00000000-0000-0000-0000-000000000043"),
                Title:           "Spicy Pasta",
                Slug:            "spicy-pasta",
                MarkdownContent: "## Ingredients\n\n- 8 oz pasta\n- 1 can tomato sauce\n- Red pepper flakes\n\n## Instructions\n\nCook pasta, add sauce and spices, serve hot.",
                Description:     stringPtr("Quick spicy pasta dinner"),
                PrepTimeMinutes: int32Ptr(5),
                CookTimeMinutes: int32Ptr(20),
                Servings:        int32Ptr(4),
                Difficulty:      stringPtr("medium"),
                IsPublished:     true,
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
        }
)

// Helper functions for creating pointers
func stringPtr(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>

func int32Ptr(i int32) *int32 <span class="cov0" title="0">{
        return &amp;i
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package testing

import (
        "database/sql"
        "os"
        "path/filepath"

        "github.com/homecooking/backend/internal/db/sqlc"
        _ "github.com/mattn/go-sqlite3"
)

// SetupTestDB creates an in-memory SQLite database for testing
func SetupTestDB() (*sql.DB, *sqlc.Queries, error) <span class="cov0" title="0">{
        db, err := sql.Open("sqlite3", ":memory:")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Enable foreign keys
        <span class="cov0" title="0">_, err = db.Exec("PRAGMA foreign_keys = ON")
        if err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, nil, err
        }</span>

        // Read migration file (SQLite-compatible for testing)
        <span class="cov0" title="0">migrationPath := filepath.Join("..", "db", "migrations", "001_init_sqlite.up.sql")
        migrationSQL, err := os.ReadFile(migrationPath)
        if err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, nil, err
        }</span>

        // Execute migration
        <span class="cov0" title="0">_, err = db.Exec(string(migrationSQL))
        if err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">q := sqlc.New(db)
        return db, q, nil</span>
}

// TeardownTestDB closes the test database connection
func TeardownTestDB(db *sql.DB) <span class="cov0" title="0">{
        if db != nil </span><span class="cov0" title="0">{
                db.Close()
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
