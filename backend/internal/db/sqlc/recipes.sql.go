// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recipes.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createRecipe = `-- name: CreateRecipe :one
INSERT INTO recipes (id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at
`

type CreateRecipeParams struct {
	ID                uuid.UUID      `json:"id"`
	Title             string         `json:"title"`
	Slug              string         `json:"slug"`
	MarkdownContent   string         `json:"markdown_content"`
	AuthorID          uuid.NullUUID  `json:"author_id"`
	CategoryID        uuid.NullUUID  `json:"category_id"`
	Description       sql.NullString `json:"description"`
	PrepTimeMinutes   sql.NullInt32  `json:"prep_time_minutes"`
	CookTimeMinutes   sql.NullInt32  `json:"cook_time_minutes"`
	Servings          sql.NullInt32  `json:"servings"`
	Difficulty        sql.NullString `json:"difficulty"`
	FeaturedImagePath sql.NullString `json:"featured_image_path"`
	IsPublished       sql.NullBool   `json:"is_published"`
}

func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) (Recipe, error) {
	row := q.db.QueryRowContext(ctx, createRecipe,
		arg.ID,
		arg.Title,
		arg.Slug,
		arg.MarkdownContent,
		arg.AuthorID,
		arg.CategoryID,
		arg.Description,
		arg.PrepTimeMinutes,
		arg.CookTimeMinutes,
		arg.Servings,
		arg.Difficulty,
		arg.FeaturedImagePath,
		arg.IsPublished,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.MarkdownContent,
		&i.AuthorID,
		&i.CategoryID,
		&i.Description,
		&i.PrepTimeMinutes,
		&i.CookTimeMinutes,
		&i.Servings,
		&i.Difficulty,
		&i.FeaturedImagePath,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
	)
	return i, err
}

const deleteRecipe = `-- name: DeleteRecipe :exec
DELETE FROM recipes WHERE id = $1
`

func (q *Queries) DeleteRecipe(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteRecipe, id)
	return err
}

const getRecipeByID = `-- name: GetRecipeByID :one
SELECT id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at FROM recipes
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRecipeByID(ctx context.Context, id uuid.UUID) (Recipe, error) {
	row := q.db.QueryRowContext(ctx, getRecipeByID, id)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.MarkdownContent,
		&i.AuthorID,
		&i.CategoryID,
		&i.Description,
		&i.PrepTimeMinutes,
		&i.CookTimeMinutes,
		&i.Servings,
		&i.Difficulty,
		&i.FeaturedImagePath,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
	)
	return i, err
}

const getRecipeBySlug = `-- name: GetRecipeBySlug :one
SELECT id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at FROM recipes
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetRecipeBySlug(ctx context.Context, slug string) (Recipe, error) {
	row := q.db.QueryRowContext(ctx, getRecipeBySlug, slug)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.MarkdownContent,
		&i.AuthorID,
		&i.CategoryID,
		&i.Description,
		&i.PrepTimeMinutes,
		&i.CookTimeMinutes,
		&i.Servings,
		&i.Difficulty,
		&i.FeaturedImagePath,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
	)
	return i, err
}

const listRecipes = `-- name: ListRecipes :many
SELECT id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at FROM recipes
WHERE is_published = true
ORDER BY published_at DESC
LIMIT $1 OFFSET $2
`

type ListRecipesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListRecipes(ctx context.Context, arg ListRecipesParams) ([]Recipe, error) {
	rows, err := q.db.QueryContext(ctx, listRecipes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.MarkdownContent,
			&i.AuthorID,
			&i.CategoryID,
			&i.Description,
			&i.PrepTimeMinutes,
			&i.CookTimeMinutes,
			&i.Servings,
			&i.Difficulty,
			&i.FeaturedImagePath,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecipesByAuthor = `-- name: ListRecipesByAuthor :many
SELECT id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at FROM recipes
WHERE author_id = $1
ORDER BY updated_at DESC
LIMIT $2 OFFSET $3
`

type ListRecipesByAuthorParams struct {
	AuthorID uuid.NullUUID `json:"author_id"`
	Limit    int32         `json:"limit"`
	Offset   int32         `json:"offset"`
}

func (q *Queries) ListRecipesByAuthor(ctx context.Context, arg ListRecipesByAuthorParams) ([]Recipe, error) {
	rows, err := q.db.QueryContext(ctx, listRecipesByAuthor, arg.AuthorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.MarkdownContent,
			&i.AuthorID,
			&i.CategoryID,
			&i.Description,
			&i.PrepTimeMinutes,
			&i.CookTimeMinutes,
			&i.Servings,
			&i.Difficulty,
			&i.FeaturedImagePath,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecipesByCategory = `-- name: ListRecipesByCategory :many
SELECT id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at FROM recipes
WHERE is_published = true
  AND category_id = $1
ORDER BY published_at DESC
LIMIT $2 OFFSET $3
`

type ListRecipesByCategoryParams struct {
	CategoryID uuid.NullUUID `json:"category_id"`
	Limit      int32         `json:"limit"`
	Offset     int32         `json:"offset"`
}

func (q *Queries) ListRecipesByCategory(ctx context.Context, arg ListRecipesByCategoryParams) ([]Recipe, error) {
	rows, err := q.db.QueryContext(ctx, listRecipesByCategory, arg.CategoryID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.MarkdownContent,
			&i.AuthorID,
			&i.CategoryID,
			&i.Description,
			&i.PrepTimeMinutes,
			&i.CookTimeMinutes,
			&i.Servings,
			&i.Difficulty,
			&i.FeaturedImagePath,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRecipes = `-- name: SearchRecipes :many
SELECT id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at FROM recipes
WHERE is_published = true
  AND (title ILIKE '%' || $1 || '%' OR description ILIKE '%' || $1 || '%')
ORDER BY published_at DESC
LIMIT $2 OFFSET $3
`

type SearchRecipesParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchRecipes(ctx context.Context, arg SearchRecipesParams) ([]Recipe, error) {
	rows, err := q.db.QueryContext(ctx, searchRecipes, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.MarkdownContent,
			&i.AuthorID,
			&i.CategoryID,
			&i.Description,
			&i.PrepTimeMinutes,
			&i.CookTimeMinutes,
			&i.Servings,
			&i.Difficulty,
			&i.FeaturedImagePath,
			&i.IsPublished,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecipe = `-- name: UpdateRecipe :one
UPDATE recipes
SET
    title = COALESCE($2, title),
    markdown_content = COALESCE($3, markdown_content),
    category_id = COALESCE($4, category_id),
    description = COALESCE($5, description),
    prep_time_minutes = COALESCE($6, prep_time_minutes),
    cook_time_minutes = COALESCE($7, cook_time_minutes),
    servings = COALESCE($8, servings),
    difficulty = COALESCE($9, difficulty),
    featured_image_path = COALESCE($10, featured_image_path),
    is_published = COALESCE($11, is_published),
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at
`

type UpdateRecipeParams struct {
	ID                uuid.UUID      `json:"id"`
	Title             sql.NullString `json:"title"`
	MarkdownContent   sql.NullString `json:"markdown_content"`
	CategoryID        uuid.NullUUID  `json:"category_id"`
	Description       sql.NullString `json:"description"`
	PrepTimeMinutes   sql.NullInt32  `json:"prep_time_minutes"`
	CookTimeMinutes   sql.NullInt32  `json:"cook_time_minutes"`
	Servings          sql.NullInt32  `json:"servings"`
	Difficulty        sql.NullString `json:"difficulty"`
	FeaturedImagePath sql.NullString `json:"featured_image_path"`
	IsPublished       sql.NullBool   `json:"is_published"`
}

func (q *Queries) UpdateRecipe(ctx context.Context, arg UpdateRecipeParams) (Recipe, error) {
	row := q.db.QueryRowContext(ctx, updateRecipe,
		arg.ID,
		arg.Title,
		arg.MarkdownContent,
		arg.CategoryID,
		arg.Description,
		arg.PrepTimeMinutes,
		arg.CookTimeMinutes,
		arg.Servings,
		arg.Difficulty,
		arg.FeaturedImagePath,
		arg.IsPublished,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.MarkdownContent,
		&i.AuthorID,
		&i.CategoryID,
		&i.Description,
		&i.PrepTimeMinutes,
		&i.CookTimeMinutes,
		&i.Servings,
		&i.Difficulty,
		&i.FeaturedImagePath,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
	)
	return i, err
}

const updateRecipeFeaturedImage = `-- name: UpdateRecipeFeaturedImage :one
UPDATE recipes
SET
    featured_image_path = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at
`

type UpdateRecipeFeaturedImageParams struct {
	ID                uuid.UUID      `json:"id"`
	FeaturedImagePath sql.NullString `json:"featured_image_path"`
}

func (q *Queries) UpdateRecipeFeaturedImage(ctx context.Context, arg UpdateRecipeFeaturedImageParams) (Recipe, error) {
	row := q.db.QueryRowContext(ctx, updateRecipeFeaturedImage, arg.ID, arg.FeaturedImagePath)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.MarkdownContent,
		&i.AuthorID,
		&i.CategoryID,
		&i.Description,
		&i.PrepTimeMinutes,
		&i.CookTimeMinutes,
		&i.Servings,
		&i.Difficulty,
		&i.FeaturedImagePath,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
	)
	return i, err
}

const updateRecipePublishedStatus = `-- name: UpdateRecipePublishedStatus :one
UPDATE recipes
SET
    is_published = $2,
    published_at = CASE WHEN $2 = true THEN NOW() ELSE published_at END,
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, slug, markdown_content, author_id, category_id, description, prep_time_minutes, cook_time_minutes, servings, difficulty, featured_image_path, is_published, created_at, updated_at, published_at
`

type UpdateRecipePublishedStatusParams struct {
	ID          uuid.UUID    `json:"id"`
	IsPublished sql.NullBool `json:"is_published"`
}

func (q *Queries) UpdateRecipePublishedStatus(ctx context.Context, arg UpdateRecipePublishedStatusParams) (Recipe, error) {
	row := q.db.QueryRowContext(ctx, updateRecipePublishedStatus, arg.ID, arg.IsPublished)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.MarkdownContent,
		&i.AuthorID,
		&i.CategoryID,
		&i.Description,
		&i.PrepTimeMinutes,
		&i.CookTimeMinutes,
		&i.Servings,
		&i.Difficulty,
		&i.FeaturedImagePath,
		&i.IsPublished,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
	)
	return i, err
}
